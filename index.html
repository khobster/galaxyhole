<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Space Cornhole — Multiplayer v3</title>

<style>
* {box-sizing:border-box;margin:0;padding:0}
html, body {height:100%;font-family:system-ui,Segoe UI,Roboto,sans-serif;background:linear-gradient(#1E3B70 0%, #090979 50%, #00d4ff 100%);overflow:hidden}

/* —— layout —— */
.screen {
  position:absolute;
  inset:0;
  display:none; /* Initially hide all screens */
  opacity:0; /* Start transparent */
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:1.5rem;
  padding:2rem;
  transform: scale(0.95); /* Start slightly scaled down for entry animation */
  /* transition: opacity .3s ease, transform .3s ease; /* Managed by show() function */
}
#setup { /* Setup screen is the default visible if no game join */
    display:flex;
    opacity:1;
    transform: scale(1);
}

#hud {position:absolute;top:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;gap:.3rem;padding:1rem;z-index:30}
#planet, #scoreAndTurn, #throws {background:rgba(255,255,255,.85);padding:.3rem .8rem;border-radius:.45rem;font-weight:600;box-shadow:0 1px 3px rgba(0,0,0,.1)}
#scoreAndTurn {flex-direction:row;gap:1rem}

/* —— board —— */
#board {
  position:absolute;
  width:120px;
  height:200px;
  left:50%;
  top:45%;
  transform:translate(-50%,-50%) perspective(800px) rotateX(10deg);
  background:#8B4513;
  border:8px solid #654321;
  border-radius:8px;
  box-shadow:0 10px 20px rgba(0,0,0,.35);
  transition: transform 0.3s ease;
  z-index: 5; /* Ensure board is behind UI like HUD but above background */
}
#hole {
  position:absolute;
  width:35px;
  height:35px;
  left:50%;
  top:20%;
  transform:translate(-50%,-50%);
  border-radius:50%;
  background:#000;
  box-shadow:inset 0 0 10px rgba(0,0,0,.5)
}
/* —— bag + shadow —— */
.bag {
  position:absolute;
  width:35px;
  height:35px;
  border-radius:5px;
  background:var(--clr);
  box-shadow:0 2px 5px rgba(0,0,0,.25);
  transform-style: preserve-3d;
  will-change:transform;
  z-index:20;
}
.shadow {
  position:absolute;
  width:35px;
  height:12px;
  border-radius:50%;
  background:rgba(0,0,0,.2);
  will-change:transform;
  filter: blur(2px);
  pointer-events:none;
  z-index:10; /* Shadow below bag */
}
/* —— trajectory —— */
.trajectory-point { /* This class is not currently used by SVG trajectory */
  position: absolute;
  width: 4px;
  height: 4px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  pointer-events: none;
  z-index: 15;
}
/* —— misc UI elements —— */
button {padding:.6rem 1.2rem;border:none;border-radius:.5rem;font-weight:600;color:#fff;background:#c41e3a;cursor:pointer}
button:hover {background:#d42e4a}
label {font-weight:500;display:block;margin-bottom:.4rem; color:white;} /* Ensure labels are visible */
select, input {padding:.5rem 1rem;border:2px solid #444;border-radius:.4rem;font:inherit;width:100%}
.input-group {width:300px;margin-bottom:1rem; z-index: 100; /* Ensure setup inputs are on top if screens overlap */ }
#instructions {background:rgba(255,255,255,.85);padding:1rem;border-radius:.5rem;max-width:400px;font-size:.9rem;line-height:1.4; color: #333;}
.waiting-animation {display:inline-block;position:relative;width:80px;height:12px}
.waiting-animation div {position:absolute;top:0;width:12px;height:12px;border-radius:50%;background:#c41e3a;animation-timing-function:cubic-bezier(0,1,1,0)}
.waiting-animation div:nth-child(1) {left:8px;animation:waiting1 1s infinite}
.waiting-animation div:nth-child(2) {left:8px;animation:waiting2 1s infinite}
.waiting-animation div:nth-child(3) {left:32px;animation:waiting2 1s infinite}
.waiting-animation div:nth-child(4) {left:56px;animation:waiting3 1s infinite}
@keyframes waiting1 {0% {transform:scale(0)} 100% {transform:scale(1)}}
@keyframes waiting2 {0% {transform:translate(0,0)} 100% {transform:translate(24px,0)}}
@keyframes waiting3 {0% {transform:scale(1)} 100% {transform:scale(0)}}

/* —— stars background —— */
.stars {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0; /* Deepest background */
  pointer-events: none;
}
.star {
  position: absolute;
  width: 2px;
  height: 2px;
  background: white;
  border-radius: 50%;
  animation: twinkle 3s infinite;
}
@keyframes twinkle {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 1; }
}

/* —— pulse animation —— */
@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}
</style>
</head>
<body>

<div class="stars" id="stars"></div>

<div id="setup" class="screen">
  <h1 style="color: white; text-shadow: 0 0 10px rgba(0, 212, 255, 0.7); font-size: 2.5rem;">Space Cornhole</h1>
  <div class="input-group">
    <label for="planetSel">Select Gravity:</label>
    <select id="planetSel">
      <option value="earth">Earth (9.8)</option>
      <option value="moon">Moon (1.6)</option>
      <option value="mars">Mars (3.7)</option>
      <option value="jupiter">Jupiter (24.8)</option>
    </select>
  </div>
  <button id="create">Create New Game</button>
  <div class="input-group">
    <label for="joinId">Join Existing Game:</label>
    <input id="joinId" placeholder="Enter Game ID" />
  </div>
  <button id="join">Join Game</button>
  <div id="instructions">
    <p><strong>How to play:</strong> Drag a bag down and back, release, and it will fly opposite your pull. Land on the board for 1 pt, in the hole for 3 pts. First to 21 wins.</p>
    <p><strong>Tip:</strong> The bag's trajectory follows realistic physics based on the selected gravity!</p>
  </div>
</div>

<div id="wait" class="screen">
  <h2 style="color: white; text-shadow: 0 0 10px rgba(0, 212, 255, 0.7);">Game Created!</h2>
  <p style="color: white;">Share this link with your opponent:</p>
  <div style="display:flex;gap:.5rem">
    <input id="link" readonly style="width:340px" />
    <button id="copy">Copy</button>
  </div>
  <p id="waitMsg" style="color: white;">Waiting for opponent…</p>
  <div class="waiting-animation"><div></div><div></div><div></div><div></div></div>
</div>

<div id="game" class="screen">
  <div id="hud">
    <div id="planet"></div>
    <div id="scoreAndTurn">
      <div id="scores">0 – 0</div>
      <div id="turn"></div>
    </div>
    <div id="throws"></div>
  </div>
  <div id="board"><div id="hole"></div></div>
</div>

<div id="result" class="screen">
  <h2 id="msg" style="color: white; text-shadow: 0 0 10px rgba(0, 212, 255, 0.7);"></h2>
  <button id="again">Play Again</button>
</div>

<div id="trajectory" style="display: none; position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:15;"></div>

<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
<script>
/* ——— Create stars background ——— */
function createStars() {
  const starsContainer = document.getElementById('stars');
  const starCount = 150;
  for (let i = 0; i < starCount; i++) {
    const star = document.createElement('div');
    star.className = 'star';
    star.style.left = `${Math.random() * 100}%`;
    star.style.top = `${Math.random() * 100}%`;
    star.style.width = `${Math.random() * 2 + 1}px`;
    star.style.height = star.style.width;
    star.style.animationDelay = `${Math.random() * 3}s`;
    starsContainer.appendChild(star);
  }
}
createStars();

/* ——— Firebase ——— */
firebase.initializeApp({
  apiKey:"AIzaSyBMuOpUCgNHUkccH_ENPE9l-iQApvdHtA4",
  authDomain:"galaxy-hole-53c76.firebaseapp.com",
  projectId:"galaxy-hole-53c76",
  storageBucket:"galaxy-hole-53c76.appspot.com",
  messagingSenderId:"592610380036",
  appId:"1:592610380036:web:4b5c72ee181682b9262851"
});
const db = firebase.firestore();

/* ——— physics + game constants ——— */
const planets = {
  earth:    {g: 9.8,  name: "Earth", color: "#87CEEB"},
  moon:     {g: 1.6,  name: "Moon", color: "#E0E0E0"},
  mars:     {g: 3.7,  name: "Mars", color: "#E27B58"},
  jupiter: {g: 24.8, name: "Jupiter", color: "#E4A788"}
};
let planet = planets.earth;
const MAX = 4, WIN = 21;
// const FRICTION = 0.7; // Not currently used in simplified launch
const AIR_RESISTANCE = 0.99; // Slightly less resistance to ensure movement
let gameId = null, me = null, turn = 1;
let throws = {1: 0, 2: 0}, score = {1: 0, 2: 0};
const pid = (()=>{ let v=localStorage.pid; if(!v){v=Math.random().toString(36).slice(2,9); localStorage.pid=v;} return v; })();

const $ = id => document.getElementById(id);
const screens = { setup: $('setup'), wait: $('wait'), game: $('game'), result: $('result') };

/* ——— Debug Mode ——— */
let debugMode = false;
document.addEventListener('keydown', e => {
  if (e.key === 'd' && e.ctrlKey) {
    debugMode = !debugMode;
    const existingDebug = document.getElementById('debug-panel');
    if (debugMode && !existingDebug) {
      const debugPanel = document.createElement('div');
      debugPanel.id = 'debug-panel';
      debugPanel.style.cssText = `position:absolute;top:10px;right:10px;background:rgba(0,0,0,0.7);color:white;padding:10px;border-radius:5px;font-family:monospace;font-size:12px;z-index:1000;pointer-events:none;`;
      document.body.appendChild(debugPanel);
    } else if (!debugMode && existingDebug) {
      existingDebug.remove();
    }
    console.log("Debug mode:", debugMode);
  }
});
function updateDebugInfo(physics = {}) { /* Omitted for brevity, no changes */ }

/* ——— Sound effects system ——— */
class SoundEffects { /* Omitted for brevity, no changes */ }
const soundEffects = new SoundEffects();

/* ——— UI handlers ——— */
$('planetSel').onchange = e => { /* Omitted for brevity, no changes */ };
$('copy').onclick = () => { /* Omitted for brevity, no changes */ };
$('again').onclick = () => location.href = location.pathname;

/* ——— Loading Indicator ——— */
function showLoadingIndicator() { /* Omitted for brevity, no changes */ }
function hideLoadingIndicator() { /* Omitted for brevity, no changes */ }

/* ——— Tutorial ——— */
function showTutorial() { /* Omitted for brevity, no changes */ }

/* ——— Restart Button ——— */
function addRestartButton() { /* Omitted for brevity, no changes */ }

/* ——— Trajectory Toggle ——— */
function addTrajectoryToggle() { /* Omitted for brevity, no changes */ }


/* ——— Screen Transitions (REVISED) ——— */
function show(scr) {
  let currentScreen = null;
  // Find the currently displayed screen
  for (const screenKey in screens) {
    if (screens.hasOwnProperty(screenKey)) {
      // Check display style OR a specific class if you prefer
      if (screens[screenKey].style.display === 'flex' || getComputedStyle(screens[screenKey]).display === 'flex') {
        if (screens[screenKey] !== scr) { // Don't mark the target screen as current if it's already the one
          currentScreen = screens[screenKey];
        }
        break;
      }
    }
  }

  // If there's a different screen currently visible, fade it out
  if (currentScreen) {
    currentScreen.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
    currentScreen.style.opacity = '0';
    currentScreen.style.transform = 'scale(0.95)';
    
    setTimeout(() => {
      currentScreen.style.display = 'none'; // Crucially hide it

      // Now show the new screen
      scr.style.display = 'flex';
      scr.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
      scr.style.opacity = '0'; // Start transparent
      scr.style.transform = 'scale(0.95)'; // Start scaled down
      
      void scr.offsetWidth; // Trigger reflow for transition
      
      scr.style.opacity = '1';
      scr.style.transform = 'scale(1)';
    }, 300); // This timeout should match the transition duration
  } else {
    // No other screen is actively displayed, or we are showing the same screen (e.g. on initial load)
    // Ensure all other screens are definitely hidden
     Object.values(screens).forEach(s => {
        if (s !== scr) {
            s.style.display = 'none';
            s.style.opacity = '0';
            s.style.transform = 'scale(0.95)';
        }
    });

    scr.style.display = 'flex';
    scr.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
    scr.style.opacity = '0';
    scr.style.transform = 'scale(0.95)';
    
    void scr.offsetWidth; // Trigger reflow
    
    scr.style.opacity = '1';
    scr.style.transform = 'scale(1)';
  }

  if (planet && planet.color) {
    document.body.style.background = `linear-gradient(${planet.color} 0%, #090979 50%, #00d4ff 100%)`;
  }
}


/* ——— Game Logic (Create, Join, Listen, UI Update) ——— */
$('create').onclick = async() => { /* Omitted for brevity, no changes */ };
async function join(id) { /* Omitted for brevity, no changes */ }
let unsub = null;
function listen() { /* Omitted for brevity, no changes */ }
function animateScoreChange(oldScore, newScore) { /* Omitted for brevity, no changes */ }
function updateUI(st) { /* Omitted for brevity, no changes, but calls spawnBag */ }
function createConfetti() { /* Omitted for brevity, no changes */ }
function createConfettiPiece(container, color) { /* Omitted for brevity, no changes */ }
function showInningSummary(p1, p2) { /* Omitted for brevity, no changes */ }


/* ——— bag / drag / throw (REVISED THROWING) ——— */
let bag, shadow, isDragging = false, startX, startY, aimLine;
let trajectoryPoints = [];

function spawnBag() {
  document.querySelectorAll('.bag,.shadow').forEach(el => el.remove());
  document.querySelectorAll('#trajectory svg').forEach(el => el.remove());
  if(aimLine) aimLine.remove();
  trajectoryPoints = [];

  bag = document.createElement('div');
  bag.className = 'bag';
  bag.style.setProperty('--clr', me === 1 ? '#c41e3a' : '#4287f5');
  const bagInner = document.createElement('div'); /* Bag inner omitted for brevity */
  bagInner.style.cssText = `position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:70%;height:70%;border-radius:3px;background:${me===1?'#d5354f':'#5c9fff'};display:flex;align-items:center;justify-content:center;font-weight:bold;color:white;font-size:10px;`;
  bagInner.textContent = me === 1 ? 'P1' : 'P2';
  bag.appendChild(bagInner);
  
  shadow = document.createElement('div'); 
  shadow.className = 'shadow';
  document.body.append(bag, shadow);

  const x = innerWidth/2 - 17.5, yVal = innerHeight - 60; // Initial screen Y
  bag.style.opacity = '0';
  bag.style.transform = `translate(${x}px, ${yVal}px) scale(0.5)`;
  shadow.style.opacity = '0';
  shadow.style.transform = `translate(${x}px, ${innerHeight-6}px) scale(0.5)`;
  
  setTimeout(() => { /* Spawn animation omitted for brevity */
    bag.style.transition = shadow.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
    bag.style.opacity = '1'; bag.style.transform = `translate(${x}px, ${yVal}px) scale(1)`;
    shadow.style.opacity = '0.6'; shadow.style.transform = `translate(${x}px, ${innerHeight-6}px) scale(0.9)`;
    if(turn===me) bag.style.boxShadow = `0 0 15px ${me===1?'rgba(196,30,58,0.7)':'rgba(66,135,245,0.7)'}`;
    setTimeout(() => { bag.style.transition = shadow.style.transition = ''; bag.addEventListener('pointerdown', dragStart, {once: true}); }, 300);
  }, 10);
  /* Tooltip omitted for brevity */
}

function dragStart(e) { /* Omitted for brevity, no changes */ }
function dragMove(e) { /* Omitted for brevity, no changes, uses predictTrajectory */ }

function dragEnd(e) {
  if(!isDragging) return; 
  isDragging = false;
  document.removeEventListener('pointermove', dragMove);
  document.removeEventListener('pointerup', dragEnd);
  document.removeEventListener('pointercancel', dragEnd);
  if(aimLine) { aimLine.remove(); aimLine = null; }
  const aimIndicator = document.getElementById('aim-indicator');
  if (aimIndicator) aimIndicator.remove();
  document.querySelectorAll('#trajectory svg').forEach(el => el.remove());
  trajectoryPoints = [];

  const pullX = e.clientX - startX;
  const pullY = e.clientY - startY;
  const dist = Math.hypot(pullX, pullY);
  
  if(dist < 10) { 
    if (turn === me && throws[me] < MAX && !document.querySelector('.bag')) { // Check if a bag needs to be spawned
        spawnBag(); 
    }
    return; 
  }

  const POWER = 14; // Slightly increased power
  const vx = (startX - e.clientX) * POWER;
  const vy = (startY - e.clientY) * POWER;
  console.log("Calculated Velocities: vx=", vx, "vy=", vy); // DEBUGGING LINE

  launchBag(vx, vy);
}

// SIMPLIFIED predictTrajectory for testing core throw
function predictTrajectory(startX, startY, vx, vy) {
    const trajectoryEnabled = localStorage.getItem('trajectoryEnabled') !== 'false';
    if (!trajectoryEnabled) {
        document.querySelectorAll('#trajectory svg').forEach(el => el.remove());
        trajectoryPoints = [];
        return;
    }
    document.querySelectorAll('#trajectory svg').forEach(el => el.remove());
    trajectoryPoints = [];

    const g = planet.g * 100; // Adjusted gravity for prediction if needed
    const dt = 1/30; // Smoother prediction
    const MAX_POINTS = 30;
    let currentX = startX;
    let currentY = startY;
    let currentVx = vx;
    let currentVy = vy; // This is the 2D plane vy

    const pathPoints = [{x: currentX, y: currentY}]; // Start with the initial point

    for (let i = 0; i < MAX_POINTS; i++) {
        currentVx *= AIR_RESISTANCE; // Apply air resistance
        currentVy += g * dt;      // Apply gravity to the main vy
        currentVy *= AIR_RESISTANCE;

        currentX += currentVx * dt;
        currentY += currentVy * dt;
        pathPoints.push({x: currentX, y: currentY});

        // Basic collision prediction (simplified)
        const boardRect = $('board').getBoundingClientRect();
        if (currentY > boardRect.top && currentY < boardRect.bottom && currentX > boardRect.left && currentX < boardRect.right) {
            break; // Stop prediction at board
        }
        if (currentY > innerHeight - 20) {
            break; // Stop at ground
        }
    }
    
    if (pathPoints.length > 1) {
        const trajectoryContainer = $('trajectory');
        let pathSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        pathSvg.setAttribute('width', '100%');
        pathSvg.setAttribute('height', '100%');
        pathSvg.style.cssText = 'position:absolute;top:0;left:0;pointer-events:none;z-index:15;';
        let pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        let pathD = `M ${pathPoints[0].x} ${pathPoints[0].y}`;
        for (let i = 1; i < pathPoints.length; i++) pathD += ` L ${pathPoints[i].x} ${pathPoints[i].y}`;
        pathElement.setAttribute('d', pathD);
        pathElement.setAttribute('fill', 'none');
        pathElement.setAttribute('stroke', me === 1 ? 'rgba(196,30,58,0.6)' : 'rgba(66,135,245,0.6)');
        pathElement.setAttribute('stroke-width', '2');
        pathElement.setAttribute('stroke-dasharray', '5,5');
        pathSvg.appendChild(pathElement);
        trajectoryContainer.appendChild(pathSvg);
        trajectoryPoints.push(pathSvg);
    }
}


// REVISED launchBag - focusing on basic 2D plane movement first
function launchBag(vx_plane, vy_plane) {
  soundEffects.playSound('throw');
  
  const initialBagRect = bag.getBoundingClientRect();
  let x = initialBagRect.left + initialBagRect.width/2; // Logical X
  let y = initialBagRect.top + initialBagRect.height/2; // Logical Y (for depth and screen Y for now)
  
  let currentVx = vx_plane;
  let currentVy = vy_plane;

  const g_plane = planet.g * 100; // Gravity for the 2D plane motion (less aggressive for testing)
  const ground = innerHeight - 10; // Ground Y threshold
  
  let last = performance.now();
  let done = false;
  let animationFrameId = null;

  let rotation = 0;
  const rotationSpeed = Math.hypot(currentVx, currentVy) / 200; // Slower rotation

  // Visual arc variables (SIMPLIFIED FOR NOW - h will represent a small visual bounce/settle on landing)
  let h = 0; // Represents a slight visual offset, not a full arc yet.
             // We will re-introduce the proper arc once basic movement is confirmed.

  console.log(`Launching bag. Initial x:${x}, y:${y}, vx:${currentVx}, vy:${currentVy}`);


  function step(now) {
    if (done) {
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      return;
    }
    animationFrameId = requestAnimationFrame(step);
    
    const dt = Math.min(0.032, (now - last) / 1000); // Cap dt to prevent large jumps
    last = now;
    
    // Update logical plane position
    currentVx *= AIR_RESISTANCE;
    currentVy += g_plane * dt; 
    currentVy *= AIR_RESISTANCE;
    
    x += currentVx * dt;
    y += currentVy * dt; // This is the primary movement we need to see
    
    rotation += rotationSpeed * dt * 60;
    
    // For now, visualScreenY is just y + a small h for landing settle
    const visualScreenY = y + h; 

    // Simplified Scaling (based on y for depth)
    let depthProgress = (y - (innerHeight * 0.1)) / (ground - (innerHeight * 0.1));
    depthProgress = Math.max(0, Math.min(1, depthProgress));
    let currentScale = 1.1 - depthProgress * 0.6; 
    currentScale = Math.max(0.4, currentScale);

    if (bag) {
        bag.style.transform = `translate(${x - 17.5}px, ${visualScreenY - 17.5}px) rotate(${rotation}deg) scale(${currentScale})`;
    }
    
    // Simplified Shadow
    if (shadow) {
        const shadowBaseY = y - 6 + 10 * currentScale; // Shadow slightly below bag's logical y
        const shadowScaleFactor = currentScale * 0.8;
        shadow.style.transform = `translate(${x - 17.5}px, ${shadowBaseY}px) scale(${shadowScaleFactor})`;
        shadow.style.opacity = (0.5 * (1-depthProgress)).toString(); // Fade shadow with distance
    }
    
    // --- Collision Detection ---
    const boardRect = $('board').getBoundingClientRect();
    const holeRect = $('hole').getBoundingClientRect();

    // Ground Collision
    if (y >= ground - (bag.offsetHeight * currentScale / 2)) {
      if (done) return; done = true;
      soundEffects.playSound('miss');
      console.log("Ground collision");
      if (bag) {
        bag.style.transition = 'opacity 0.2s ease-out, transform 0.2s ease-out';
        bag.style.opacity = '0';
        bag.style.transform = `translate(${x - 17.5}px, ${visualScreenY - 17.5}px) scale(${currentScale * 0.8})`;
      }
      if (shadow) shadow.style.opacity = '0';
      setTimeout(() => { if(bag) bag.remove(); if(shadow) shadow.remove(); finishThrow(0); }, 200);
      return;
    }

    // Board/Hole Collision (Simplified check)
    if (currentVy > 0 && x > boardRect.left && x < boardRect.right && y > boardRect.top && y < boardRect.bottom + 10) {
      if (done) return; 
      
      const cxHole = holeRect.left + holeRect.width/2;
      const cyHole = holeRect.top + holeRect.height/2;
      const inHole = Math.hypot(x - cxHole, y - cyHole) < holeRect.width/2 * 0.85;

      if (inHole) {
        done = true; soundEffects.playSound('hole'); console.log("In hole!");
        // Simplified hole animation
        if (bag) {
            bag.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
            bag.style.opacity = '0';
            bag.style.transform = `translate(${x-17.5}px, ${y-17.5 + 20}px) scale(0.3)`; // Fall down
        }
        if (shadow) shadow.style.opacity = '0';
        setTimeout(() => { if(bag) bag.remove(); if(shadow) shadow.remove(); finishThrow(3); }, 300);
        return;
      } else { // On Board
        done = true; soundEffects.playSound('boardHit'); console.log("On board!");
        // Simplified board landing: Stop movement, make it stick
        currentVx = 0; currentVy = 0; // Stop logical movement
        h = -5; // Slight visual lift to appear on board surface
        if (bag) {
            bag.style.transform = `translate(${x - 17.5}px, ${y + h - 17.5}px) rotate(${rotation}deg) scale(${currentScale})`;
        }
        if(shadow) shadow.style.opacity = '0.1'; // Dim shadow on board
        // Bag stays, finishThrow will handle next turn logic
        setTimeout(() => { finishThrow(1); }, 50); // Short delay before scoring
        return; 
      }
    }

    // Off-screen failsafe
    if (x < -100 || x > innerWidth + 100 || y < -100 || y > innerHeight + 200) { // Increased y bound
      if (done) return; done = true;
      console.log("Off-screen failsafe");
      soundEffects.playSound('miss');
      if(bag) bag.remove(); if(shadow) shadow.remove();
      finishThrow(0);
      return;
    }
  }
  animationFrameId = requestAnimationFrame(step);
}


/* ——— scoring ——— */
function finishThrow(pts) { /* Omitted for brevity, no changes */ }
function showFlyText(pts) { /* Omitted for brevity, no changes */ }

/* ——— Board perspective tilting based on mouse position ——— */
document.addEventListener('mousemove', (e) => { /* Omitted for brevity, no changes */ });

/* ——— Cheat Code ——— */
const cheatSequence = [];
document.addEventListener('keydown', e => { /* Omitted for brevity, no changes */ });
function activateZeroGravity() { /* Omitted for brevity, no changes */ }

/* ——— Mobile Optimizations ——— */
function optimizeForMobile() { /* Omitted for brevity, no changes */ }

// Initialize all enhanced features when DOM is loaded
window.addEventListener('DOMContentLoaded', () => {
  optimizeForMobile();
  const lastPlanet = localStorage.getItem('lastPlanet');
  if (lastPlanet && planets[lastPlanet]) { /* Omitted for brevity */ }
  
  let trajectoryToggleAdded = false;
  const checkInterval = setInterval(() => { /* Omitted for brevity */ }, 1000);

  const qp = new URLSearchParams(location.search);
  if (qp.has('id')) {
    const gameToJoin = qp.get('id');
    $('joinId').value = gameToJoin; 
    join(gameToJoin);
  } else {
    show(screens.setup); // Show setup if not joining
  }
});
</script>
</body>
</html>
