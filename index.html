<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Space Cornhole - 2 Player</title>
  <style>
    /* General reset */
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      overflow: hidden;
      touch-action: none;
    }

    /* Common style for all screens */
    .screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: linear-gradient(#87CEEB, #90EE90);
      z-index: 100;
    }

    #setupScreen {
      display: flex;
    }

    #setupScreen h1 {
      font-size: 48px;
      margin-bottom: 20px;
      color: #333;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
    }

    #setupScreen button,
    #setupScreen input {
      font-size: 18px;
      margin: 10px;
      padding: 12px 20px;
      border-radius: 8px;
    }

    #setupScreen input {
      width: 200px;
      border: 2px solid #ddd;
    }

    /* Planet selection in setup screen */
    #planetSelectSetup {
      margin-bottom: 20px;
      font-size: 18px;
      background: rgba(255, 255, 255, 0.9);
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #waitingScreen p {
      font-size: 20px;
      margin: 15px;
      color: #333;
    }

    #gameLink {
      margin: 20px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    #gameLink input {
      padding: 8px;
      margin-right: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      width: 400px;
    }

    /* Game Screen */
    #gameScreen {
      position: relative;
      cursor: grab;
    }

    #gameScreen.dragging {
      cursor: grabbing;
    }

    #game-container {
      width: 100vw;
      height: 100vh;
      perspective: 2000px;
      perspective-origin: 50% 100%;
      position: relative;
      overflow: hidden;
    }

    #scene {
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
      position: absolute;
      top: 0;
      left: 0;
      transform: rotateX(20deg);
    }

    /* Board positioning */
    #board {
      position: absolute;
      width: 120px;
      height: 240px;
      left: 50%;
      top: 35%;
      transform-style: preserve-3d;
      transform-origin: center bottom;
      transform: translate(-50%, -50%) translateZ(0px);
      background: #8B4513;
      border: 4px solid #654321;
      border-radius: 4px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
      z-index: 500;
    }

    #hole {
      position: absolute;
      width: 35px;
      height: 35px;
      left: 50%;
      top: 25%;
      transform: translate(-50%, -50%);
      background: #000;
      border-radius: 50%;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
    }

    /* Ground plane for better perspective */
    #ground {
      position: absolute;
      width: 100%;
      height: 40%;
      bottom: 0;
      left: 0;
      background: rgba(144, 238, 144, 0.1);
      transform: rotateX(70deg) translateZ(-100px);
      transform-origin: bottom;
      box-shadow: 0 -20px 50px rgba(0, 0, 0, 0.1);
      z-index: 100;
    }

    /* Debug position marker */
    .position-marker {
      position: absolute;
      width: 5px;
      height: 5px;
      background: red;
      border-radius: 50%;
      z-index: 1000;
      pointer-events: none;
    }

    /* Bag styling */
    .bag {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 5px;
      box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
      transform-style: preserve-3d;
      will-change: transform, opacity, z-index;
      z-index: 600;
    }

    .bag-shadow {
      position: absolute;
      width: 40px;
      height: 40px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 50%;
      transform: translateY(10px) scaleY(0.3) rotateX(90deg);
      opacity: 0.5;
      z-index: 50;
    }

    /* Trajectory styling */
    #trajectory {
      position: absolute;
      width: 100%;
      height: 100%;
      pointer-events: none;
      top: 0;
      left: 0;
      z-index: 1;
    }

    .trail-particle {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 3px;
      opacity: 0;
      animation: fadeOut 0.6s forwards;
      pointer-events: none;
    }

    @keyframes fadeOut {
      0% { opacity: 0.8; }
      100% { opacity: 0; }
    }

    /* UI Elements */
    #scoreDisplay {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 24px;
      background: rgba(255, 255, 255, 0.9);
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }

    #selectedPlanet {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 18px;
      background: rgba(255, 255, 255, 0.9);
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }

    #tryCounter {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 24px;
      background: rgba(255, 255, 255, 0.9);
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }

    #throwInstructions {
      position: absolute;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 18px;
      background: rgba(255, 255, 255, 0.9);
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      text-align: center;
      pointer-events: none;
    }

    /* Power meter */
    #powerMeter {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 10px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 5px;
      overflow: hidden;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 1000;
    }

    #powerFill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #4CAF50, #FFC107, #F44336);
      transition: width 0.1s;
    }

    /* Throw preview */
    #throwPreview {
      position: absolute;
      pointer-events: none;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .preview-line {
      position: absolute;
      width: 2px;
      height: 100%;
      background: rgba(255, 255, 255, 0.5);
      transform-origin: top;
    }

    /* Common button styles */
    button {
      background: #c41e3a;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      text-transform: uppercase;
      user-select: none;
      transition: transform 0.1s, background 0.2s;
      padding: 12px 24px;
    }

    button:hover {
      background: #d42e4a;
    }

    button:active {
      transform: scale(0.95);
    }

    button:disabled {
      background: #999;
      cursor: not-allowed;
    }

    #copyStatus {
      margin-top: 8px;
      color: green;
      display: none;
      text-align: center;
    }

    /* Error message */
    #errorScreen {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.9);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      padding: 20px;
      text-align: center;
    }

    #errorScreen h2 {
      color: #c41e3a;
      margin-bottom: 20px;
    }

    #errorScreen p {
      max-width: 600px;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <div id="setupScreen" class="screen">
    <h1>Space Cornhole</h1>
    <div id="planetSelectSetup">
      <label for="planet-select-setup">Select Planet:</label>
      <select id="planet-select-setup">
        <option value="earth">Earth (9.81)</option>
        <option value="moon">Moon (1.62)</option>
        <option value="mars">Mars (3.72)</option>
        <option value="jupiter">Jupiter (24.79)</option>
      </select>
    </div>
    <button id="create-game">Create Game</button>
    <input type="text" id="gameIdInput" placeholder="Game ID">
    <button id="join-game">Join Game</button>
  </div>

  <div id="waitingScreen" class="screen">
    <p>Game created! Share this link with your friend:</p>
    <div id="gameLink"></div>
    <p id="waitingMessage">Waiting for opponent to join...</p>
  </div>

  <div id="gameScreen" class="screen">
    <div id="game-container">
      <div id="scene">
        <div id="trajectory"></div>
        <div id="board">
          <div id="hole"></div>
        </div>
        <div id="ground"></div>
      </div>
      <div id="scoreDisplay">Score - Player 1: 0 | Player 2: 0</div>
      <div id="selectedPlanet">Playing on: Earth</div>
      <div id="tryCounter">Waiting for game...</div>
      <div id="throwInstructions">Quick swipe up for more power! Angle for direction.</div>
      <div id="powerMeter">
        <div id="powerFill"></div>
      </div>
      <div id="throwPreview">
        <div class="preview-line"></div>
      </div>
    </div>
  </div>

  <div id="resultScreen" class="screen">
    <h2>Game Over!</h2>
    <p id="resultMessage"></p>
    <button id="restart-game">Play Again</button>
  </div>

  <div id="errorScreen">
    <h2>Loading Error</h2>
    <p>There was a problem loading Firebase. This might be due to ad blockers, network issues, or privacy extensions.</p>
    <p>To fix this:</p>
    <ol style="text-align: left; display: inline-block;">
      <li>Disable ad blockers or privacy extensions for this page</li>
      <li>Check your internet connection</li>
      <li>Try using a different browser</li>
    </ol>
    <button id="retry-loading">Try Again</button>
  </div>

  <!-- Load Firebase with fallback handling -->
  <script>
    // This variable will track if we've attempted to reload
    let firebaseReloadAttempt = false;
    
    // Function to check if Firebase is loaded
    function isFirebaseLoaded() {
      return typeof firebase !== 'undefined';
    }
    
    // Function to show error screen
    function showFirebaseError() {
      document.getElementById('errorScreen').style.display = 'flex';
    }
    
    // Function to retry loading
    function retryLoading() {
      if (!firebaseReloadAttempt) {
        firebaseReloadAttempt = true;
        document.getElementById('errorScreen').style.display = 'none';
        
        // Reload scripts
        const appScript = document.createElement('script');
        appScript.src = "https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js";
        appScript.onload = function() {
          const firestoreScript = document.createElement('script');
          firestoreScript.src = "https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js";
          firestoreScript.onload = function() {
            initializeApp();
          };
          firestoreScript.onerror = showFirebaseError;
          document.body.appendChild(firestoreScript);
        };
        appScript.onerror = showFirebaseError;
        document.body.appendChild(appScript);
      } else {
        // If we've already tried once, provide more guidance
        alert("Still having trouble loading Firebase. Please check your internet connection and browser extensions.");
      }
    }
    
    // Add event listener to retry button
    document.getElementById('retry-loading').addEventListener('click', retryLoading);
  </script>

  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
  
  <script>
    // Initialize the application only when Firebase is available
    function initializeApp() {
      if (!isFirebaseLoaded()) {
        showFirebaseError();
        return;
      }
      
      try {
        // Firebase initialization
        const firebaseConfig = {
          apiKey: "AIzaSyBMuOpUCgNHUkccH_ENPE9l-iQApvdHtA4",
          authDomain: "galaxy-hole-53c76.firebaseapp.com",
          projectId: "galaxy-hole-53c76",
          storageBucket: "galaxy-hole-53c76.firebaseapp.com",
          messagingSenderId: "592610380036",
          appId: "1:592610380036:web:4b5c72ee181682b9262851",
          measurementId: "G-6KWKF4T304"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        // Game state
        let gameId = null;
        let currentPlayer = null;
        let localPlayerNum = null;
        const totalThrows = 4;
        let player1Throws = 0;
        let player2Throws = 0;
        const playerId = generatePlayerId();
        let currentBagEl = null;
        let currentBagShadowEl = null;
        let isAnimating = false;
        let isDragging = false;
        let dragStart = null;
        let minimumDragDistance = 10; // Reduced for more sensitivity
        let time = 0;
        let animationFrameId = null;

        // Scoring state
        let gameScores = {
          player1: 0,
          player2: 0
        };

        const POINTS_IN_HOLE = 3;
        const POINTS_ON_BOARD = 1;
        const WINNING_SCORE = 21;
        const HOLE_RADIUS = 20; // Increased for better playability

        // DOM Elements
        const tryCounterEl = document.getElementById('tryCounter');
        const scoreDisplayEl = document.getElementById('scoreDisplay');
        const planetSelectSetup = document.getElementById('planet-select-setup');
        const selectedPlanetEl = document.getElementById('selectedPlanet');
        const sceneEl = document.getElementById('scene');
        const trajectoryContainer = document.getElementById('trajectory');
        const gameLinkEl = document.getElementById('gameLink');
        const boardEl = document.getElementById('board');
        const gameScreenEl = document.getElementById('gameScreen');
        const throwPreviewEl = document.getElementById('throwPreview');
        const throwInstructionsEl = document.getElementById('throwInstructions');
        const powerMeterEl = document.getElementById('powerMeter');
        const powerFillEl = document.getElementById('powerFill');

        // Constants
        const player1Color = "#c41e3a";
        const player2Color = "#4287f5";
        const boardZ = 0; // Board is at z=0 
        const boardY = window.innerHeight * 0.35; // Board position from top (35%)
        const bagStartY = window.innerHeight - 200; // Starting bag position
        const boardWidth = 120; // Width of board in px
        const boardHeight = 240; // Height of board in px

        // Planet settings
        const planets = {
          earth: { gravity: 9.81, throwAdjustment: 1.0 },
          moon: { gravity: 1.62, throwAdjustment: 0.6 },
          mars: { gravity: 3.72, throwAdjustment: 0.8 },
          jupiter: { gravity: 24.79, throwAdjustment: 1.5 }
        };
        let currentPlanet = planets.earth;

        // Screen management
        function showScreen(screenId) {
          document.querySelectorAll('.screen').forEach(screen => {
            screen.style.display = screen.id === screenId ? "flex" : "none";
          });
        }

        // Game creation with planet selection
        async function createNewGame() {
          try {
            const selectedPlanet = planetSelectSetup.value;
            const gameRef = await db.collection('cornholeGames').add({
              player1Id: playerId,
              player2Id: null,
              currentPlayer: 1,
              player1Throws: 0,
              player2Throws: 0,
              gameStatus: 'waiting',
              gameScores: { player1: 0, player2: 0 },
              planet: selectedPlanet,
              bagsInPlay: {
                player1: [],
                player2: []
              }
            });

            gameId = gameRef.id;
            localPlayerNum = 1;
            
            // Set current planet based on selection
            currentPlanet = planets[selectedPlanet];
            selectedPlanetEl.textContent = `Playing on: ${selectedPlanet.charAt(0).toUpperCase() + selectedPlanet.slice(1)}`;

            // Create shareable link with proper formatting
            const shareLink = `${window.location.origin}${window.location.pathname}?gameId=${gameId}`;

            // Add copy functionality with better UX
            gameLinkEl.innerHTML = `
              <div style="display: flex; gap: 10px; align-items: center;">
                <input type="text" value="${shareLink}" readonly style="width: 400px; padding: 8px;">
                <button id="copyLink" style="padding: 8px 16px;">Copy Link</button>
              </div>
              <div id="copyStatus" style="margin-top: 8px; color: green; display: none;">Link copied!</div>
            `;

            document.getElementById('copyLink').addEventListener('click', () => {
              const input = gameLinkEl.querySelector('input');
              input.select();
              navigator.clipboard.writeText(shareLink)
                .then(() => {
                  const status = document.getElementById('copyStatus');
                  status.style.display = 'block';
                  setTimeout(() => {
                    status.style.display = 'none';
                  }, 2000);
                })
                .catch(err => console.error("Copy failed", err));
            });

            showScreen("waitingScreen");
            startGameListener();
          } catch (err) {
            console.error("Error creating game:", err);
            alert("Failed to create game. Please try again.");
          }
        }

        // Game joining with planet inheritance
        async function joinGame(gameIdToJoin) {
          if (!gameIdToJoin) {
            alert("Please enter a game ID");
            return;
          }

          try {
            const gameRef = db.collection('cornholeGames').doc(gameIdToJoin);
            const doc = await gameRef.get();

            if (!doc.exists) {
              alert("Game not found");
              return;
            }

            const data = doc.data();
            
            // Set planet from game data
            const gamePlanet = data.planet || 'earth';
            currentPlanet = planets[gamePlanet];
            selectedPlanetEl.textContent = `Playing on: ${gamePlanet.charAt(0).toUpperCase() + gamePlanet.slice(1)}`;

            if (data.player1Id === playerId || data.player2Id === playerId) {
              // Rejoining existing game
              localPlayerNum = data.player1Id === playerId ? 1 : 2;
              gameId = gameIdToJoin;
              gameScores = data.gameScores || { player1: 0, player2: 0 };
              player1Throws = data.player1Throws;
              player2Throws = data.player2Throws;

              // Recreate any bags that were in play
              recreateBagsFromState(data.bagsInPlay);

              updateScoreDisplay();
              updateTryCounter();
              showScreen("gameScreen");
              startGameListener();
            } else if (!data.player2Id && data.gameStatus === 'waiting') {
              // Joining as player 2
              await gameRef.update({
                player2Id: playerId,
                gameStatus: 'started'
              });
              localPlayerNum = 2;
              gameId = gameIdToJoin;
              showScreen("gameScreen");
              startGameListener();
            } else {
              alert("Cannot join game - it may be full or already ended");
            }
          } catch (err) {
            console.error("Error joining game:", err);
            alert("Failed to join game. Please try again.");
          }
        }

        // Improved bag recreation for consistent persistence
        function recreateBagsFromState(bagsInPlay) {
          if (!bagsInPlay) return;
          
          // Only clear existing bags that aren't the current player's active bag
          document.querySelectorAll('.bag, .bag-shadow').forEach(el => {
            // Fix the null error by checking if bag exists before removing
            if (el && (el !== currentBagEl && el !== currentBagShadowEl)) {
              el.remove();
            }
          });

          // Sort bags by timestamp to maintain throw order
          const recreateBagsForPlayer = (bags, color) => {
            if (!bags || !Array.isArray(bags)) return;
            
            const sortedBags = [...bags].sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
            
            sortedBags.forEach(bagData => {
              // Check if this is already the current bag being thrown - don't recreate it
              if (currentBagEl && 
                  Math.abs(parseFloat(currentBagEl.style.transform.split('translate3d(')[1]) - (bagData.x - 20)) < 5) {
                return;
              }
              
              // Create the bag
              const bag = document.createElement('div');
              bag.classList.add('bag');
              bag.style.background = color;
              sceneEl.appendChild(bag);
              
              // Create shadow
              if (!bagData.isInHole) {
                const shadow = document.createElement('div');
                shadow.classList.add('bag-shadow');
                sceneEl.appendChild(shadow);
                
                // Position shadow under bag
                shadow.style.transform = `translate3d(${bagData.x - 20}px, ${bagData.y}px, 1px) scaleY(0.3) rotateX(90deg)`;
              }
              
              // Position appropriately based on if it's in the hole
              if (bagData.isInHole) {
                // Find hole position
                const holeX = window.innerWidth / 2;
                const holeY = boardY + 60; // Position for hole
                bag.style.transform = 
                  `translate3d(${holeX - 20}px, ${holeY - 20}px, -10px) scale(0.8) rotate(${bagData.rotation || 0}deg)`;
                bag.style.opacity = '0.7';
              } else {
                bag.style.transform =
                  `translate3d(${bagData.x - 20}px, ${bagData.y - 20}px, 10px) rotate(${bagData.rotation || 0}deg)`;
              }
              
              // Set appropriate z-index
              bag.style.zIndex = bagData.isInHole ? 490 : 510; // Below or above board
            });
          };

          // Always recreate both players' bags
          recreateBagsForPlayer(bagsInPlay.player1, player1Color);
          recreateBagsForPlayer(bagsInPlay.player2, player2Color);
        }

        // Game state listener with improved turn handling
        function startGameListener() {
          const gameRef = db.collection('cornholeGames').doc(gameId);

          gameRef.onSnapshot(doc => {
            if (!doc.exists) return;

            const data = doc.data();
            currentPlayer = data.currentPlayer;
            player1Throws = data.player1Throws;
            player2Throws = data.player2Throws;
            gameScores = data.gameScores || gameScores;
            
            // Update planet from game state if available
            if (data.planet) {
              currentPlanet = planets[data.planet];
              selectedPlanetEl.textContent = `Playing on: ${data.planet.charAt(0).toUpperCase() + data.planet.slice(1)}`;
            }

            // Log current state
            console.log(`Current state: Player ${currentPlayer}'s turn, P1 throws: ${player1Throws}/${totalThrows}, P2 throws: ${player2Throws}/${totalThrows}`);

            // Recreate bags if they changed
            if (data.bagsInPlay) {
              recreateBagsFromState(data.bagsInPlay);
            }

            updateTryCounter();
            updateScoreDisplay();

            if (data.gameStatus === 'started') {
              showScreen("gameScreen");
              
              // Create a new bag if it's player's turn and they haven't used all throws
              // and don't already have a bag
              if (!currentBagEl && localPlayerNum === currentPlayer &&
                  ((localPlayerNum === 1 && player1Throws < totalThrows) ||
                   (localPlayerNum === 2 && player2Throws < totalThrows))) {
                console.log(`Creating new bag for Player ${localPlayerNum}`);
                createBagWithShadow();
              }
              
              // Show/hide instructions based on turn
              throwInstructionsEl.style.display = 
                localPlayerNum === currentPlayer ? 'block' : 'none';
              powerMeterEl.style.opacity = 
                localPlayerNum === currentPlayer ? '1' : '0';
            } else if (data.gameStatus === 'ended') {
              showResult();
            }
          }, error => {
            console.error("Game listener error:", error);
          });
        }

        // Enhanced drag mechanics
        function startDrag(e) {
          if (isAnimating || !currentBagEl || currentPlayer !== localPlayerNum) return;

          e.preventDefault();
          isDragging = true;
          gameScreenEl.classList.add('dragging');

          const point = e.touches ? e.touches[0] : e;
          dragStart = {
            x: point.clientX,
            y: point.clientY,
            time: performance.now()
          };

          throwPreviewEl.style.opacity = '1';
          throwPreviewEl.style.left = `${dragStart.x}px`;
          throwPreviewEl.style.top = `${dragStart.y}px`;
          powerMeterEl.style.opacity = '1';
        }

        function updateDrag(e) {
          if (!isDragging) return;

          e.preventDefault();
          const point = e.touches ? e.touches[0] : e;
          const deltaX = point.clientX - dragStart.x;
          const deltaY = point.clientY - dragStart.y;

          // Update throw preview line
          const angle = Math.atan2(-deltaY, deltaX);
          const length = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), 200);

          // Update power meter with increased sensitivity
          const power = Math.min(100, (length / 200) * 100);
          powerFillEl.style.width = `${power}%`;

          throwPreviewEl.style.transform = `rotate(${angle}rad)`;
          throwPreviewEl.querySelector('.preview-line').style.height = `${length}px`;

          // Update bag position preview
          if (currentBagEl) {
            const previewX = dragStart.x + deltaX * 0.1;
            const previewY = dragStart.y + deltaY * 0.1;
            currentBagEl.style.transform =
              `translate3d(${previewX - 20}px, ${previewY - 20}px, 0px)`;
              
            // Update shadow position
            if (currentBagShadowEl) {
              currentBagShadowEl.style.transform =
                `translate3d(${previewX - 20}px, ${previewY + 10}px, 0px) scaleY(0.3) rotateX(90deg)`;
            }
          }
        }

        function endDrag(e) {
          if (!isDragging) return;

          e.preventDefault();
          isDragging = false;
          gameScreenEl.classList.remove('dragging');
          throwPreviewEl.style.opacity = '0';
          powerMeterEl.style.opacity = '0';
          powerFillEl.style.width = '0%';

          const point = e.changedTouches ? e.changedTouches[0] : e;
          const deltaX = point.clientX - dragStart.x;
          const deltaY = dragStart.y - point.clientY;  // Inverted for upward throw
          const deltaTime = performance.now() - dragStart.time;

          // More sensitive throwing mechanics
          if (deltaTime < 500 && Math.sqrt(deltaX * deltaX + deltaY * deltaY) > minimumDragDistance) {
            const speed = Math.sqrt(deltaX * deltaX + deltaY * deltaY) / deltaTime;
            const angle = Math.atan2(deltaY, deltaX);
            
            // Make power more directly related to drag speed/distance
            const power = Math.min(100, speed * 300); // Scale based on speed
            
            // Pass the raw angle to influence where the bag lands
            throwBag(power, angle, deltaX);
          } else {
            setBagStartPosition();
          }

          dragStart = null;
        }

        // Create bag with shadow
        function createBagWithShadow() {
          // Create the bag
          currentBagEl = document.createElement('div');
          currentBagEl.classList.add('bag');
          currentBagEl.style.background = localPlayerNum === 1 ? player1Color : player2Color;
          sceneEl.appendChild(currentBagEl);
          
          // Create shadow
          currentBagShadowEl = document.createElement('div');
          currentBagShadowEl.classList.add('bag-shadow');
          sceneEl.appendChild(currentBagShadowEl);
          
          // Position both elements
          setBagStartPosition();
          
          return currentBagEl;
        }

        function setBagStartPosition() {
          if (!currentBagEl) return;
          
          const gameW = window.innerWidth;
          const bagWidth = 40;
          const startX = gameW * 0.5;
          
          // Position the bag
          currentBagEl.style.transform = `translate3d(${startX - bagWidth / 2}px, ${bagStartY - bagWidth / 2}px, 0px)`;
          currentBagEl.style.zIndex = '600';
          
          // Position shadow under bag
          if (currentBagShadowEl) {
            currentBagShadowEl.style.transform = 
              `translate3d(${startX - bagWidth / 2}px, ${bagStartY + 10}px, 0px) scaleY(0.3) rotateX(90deg)`;
          }
        }

        // COMPLETELY REDESIGNED: Realistic throw trajectory with dynamic landing positions
        function throwBag(power, angle, horizontalAdjustment) {
          // Cancel any existing animation
          if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
          }
          
          if (isAnimating || !currentBagEl) return;
          isAnimating = true;
          time = 0;

          const gameW = window.innerWidth;
          const bagWidth = 40;
          const startX = gameW * 0.5;
          const startY = bagStartY;
          const startZ = 0;
          
          // Center of the board
          const boardCenterX = window.innerWidth / 2;
          const boardCenterY = boardY;

          // Enhanced throwing physics with planet adjustment and random variations
          const throwVelocity = power * 0.8 * currentPlanet.throwAdjustment; 
          const gravity = currentPlanet.gravity * 0.02;
          
          // Calculate landing position based on angle and power
          // This now directly influences where the bag will land
          const angleOffset = (angle / Math.PI) * 2; // Convert angle to a -2 to 2 range
          
          // Horizontal deviation based on angle (-60 to +60 pixels from center)
          const horizontalDeviation = angleOffset * 80 + horizontalAdjustment * 0.3;
          
          // Calculate target position (where bag will land)
          const targetX = boardCenterX + horizontalDeviation;
          
          // Vertical position based on power (higher power = further up the board)
          // Power range: 0-100, board height: 240px
          const verticalPosition = boardCenterY - 120 + (power / 100) * 240;
          const targetY = Math.min(Math.max(verticalPosition, boardCenterY - 110), boardCenterY + 110);
          
          // Add slight randomness to landing position for realism
          const randomX = targetX + (Math.random() * 20 - 10);
          const randomY = targetY + (Math.random() * 20 - 10);
          
          // Finalize target position
          const landX = randomX;
          const landY = randomY;
          
          // Calculate if it's in the hole based on distance from hole center
          const holeX = boardCenterX;
          const holeY = boardCenterY + 60;
          const distanceFromHole = Math.sqrt(
            Math.pow(landX - holeX, 2) + 
            Math.pow(landY - holeY, 2)
          );
          
          // More accurate hole detection
          // Higher chance of going in if it's very close to the hole
          const isInHole = distanceFromHole <= HOLE_RADIUS;
          
          // Calculate path - we'll use a quadratic bezier curve for a natural arc
          // Bag will fly up and then down in a natural arc
          const midpointX = (startX + landX) / 2;
          const arcHeight = Math.min(window.innerHeight * 0.6 - startY, 200) * (power / 100);
          const midpointY = startY - arcHeight;
          
          // Animation will use cubic bezier for X/Y and linear for Z
          const duration = 1.5; // Animation duration in seconds (slower for better visibility)
          
          // Starting properties
          let posX = startX;
          let posY = startY;
          let posZ = startZ;
          let bagScale = 1.0;
          let rotationX = 0;
          let rotationZ = 0;
          let shadowOpacity = 0.5;
          let shadowScale = 0.3;
          let hasLanded = false;
          
          // Function to calculate position at a given time using quadratic bezier
          function bezier(t, p0, p1, p2) {
            const mt = 1 - t;
            return mt * mt * p0 + 2 * mt * t * p1 + t * t * p2;
          }

          // Debug: Show target landing position
          //const marker = document.createElement('div');
          //marker.className = 'position-marker';
          //marker.style.left = `${landX}px`;
          //marker.style.top = `${landY}px`;
          //document.body.appendChild(marker);
          //setTimeout(() => marker.remove(), 2000);

          function animate() {
            time += 0.016; // Roughly 60fps
            const t = Math.min(time / duration, 1); // Normalized progress (0-1)
            
            // Smooth easing for beginning and end
            const eased = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            
            // Calculate current position using bezier curve for natural arc
            posX = bezier(t, startX, midpointX, landX);
            posY = bezier(t, startY, midpointY, landY);
            
            // Z moves toward the board - linear interpolation
            posZ = startZ + (t * 1000) - 500; // Max height at middle of throw
            
            // Scale based on distance - bag appears smaller at apex of throw
            const distanceScale = 1 - (Math.sin(t * Math.PI) * 0.2);
            bagScale = distanceScale;
            
            // Add realistic rotation - more rotation near the end
            rotationX += 6 * (t * 2 + 0.5); // Faster rotation during arc
            rotationZ += 4 * (t * 2 + 0.5);
            
            // Shadow gets fainter as bag gets higher
            shadowOpacity = Math.max(0.1, 0.5 - Math.sin(t * Math.PI) * 0.4);
            
            // Shadow gets smaller as bag gets higher or farther
            shadowScale = Math.max(0.1, 0.3 - Math.sin(t * Math.PI) * 0.2);
            
            // Position the bag
            currentBagEl.style.transform = 
              `translate3d(${posX - bagWidth/2}px, ${posY - bagWidth/2}px, ${posZ}px) 
               scale(${bagScale}) rotateX(${rotationX}deg) rotateZ(${rotationZ}deg)`;
            
            // Update shadow position and appearance
            if (currentBagShadowEl) {
              const shadowX = posX; 
              const shadowY = bezier(t, startY + 20, boardY - 80, landY + 20);
              
              currentBagShadowEl.style.transform = 
                `translate3d(${shadowX - bagWidth/2}px, ${shadowY}px, 1px) 
                 scaleY(${shadowScale}) scaleX(${distanceScale * 0.8}) rotateX(90deg)`;
              currentBagShadowEl.style.opacity = shadowOpacity;
            }
            
            // Create trail effect - less frequent to match new flight time
            if (time * 1000 % 40 < 8) {
              createTrailParticle(posX, posY, posZ);
            }

            // End of animation - bag has landed
            if (t >= 0.98 && !hasLanded) {
              hasLanded = true;
              
              // Final rotation
              const finalRotation = Math.random() * 360;
              
              // Check if the bag landed on the board (based on position)
              const onBoard = Math.abs(landX - boardCenterX) < (boardWidth / 2) && 
                            Math.abs(landY - boardCenterY) < (boardHeight / 2);
              
              if (onBoard) {
                currentBagEl.style.transition = 'transform 0.3s ease-out';
                
                if (isInHole) {
                  // In the hole!
                  currentBagEl.style.transform =
                    `translate3d(${holeX - bagWidth/2}px, ${holeY - bagWidth/2}px, -10px) 
                     scale(0.8) rotate(${finalRotation}deg)`;
                  currentBagEl.style.zIndex = '490'; // Below board surface
                  currentBagEl.style.opacity = '0.7'; // Partially visible
                  
                  // Remove shadow for in-hole bags
                  if (currentBagShadowEl) {
                    currentBagShadowEl.style.opacity = '0';
                  }
                  
                  // Create hole-in effect
                  createHoleInEffect(holeX, holeY);
                } else {
                  // On the board
                  currentBagEl.style.transform =
                    `translate3d(${landX - bagWidth/2}px, ${landY - bagWidth/2}px, 5px) 
                     rotate(${finalRotation}deg)`;
                  currentBagEl.style.zIndex = '510'; // Above board surface
                  
                  // Position shadow
                  if (currentBagShadowEl) {
                    currentBagShadowEl.style.transform = 
                      `translate3d(${landX - bagWidth/2}px, ${landY}px, 1px) 
                       scaleY(0.2) rotateX(90deg)`;
                    currentBagShadowEl.style.opacity = '0.3';
                  }
                }
                
                // Register the score
                registerScore(landX, landY, finalRotation, isInHole);
              } else {
                // Missed the board
                currentBagEl.style.opacity = '0';
                if (currentBagShadowEl) {
                  currentBagShadowEl.style.opacity = '0';
                }
                
                setTimeout(() => {
                  if (currentBagEl) currentBagEl.remove();
                  if (currentBagShadowEl) currentBagShadowEl.remove();
                  finishThrow();
                }, 300);
              }
            }

            if (!hasLanded && t < 1) {
              animationFrameId = requestAnimationFrame(animate);
            } else {
              isAnimating = false;
              animationFrameId = null;
              
              if (!hasLanded) {
                // Safety fallback if animation ended but bag didn't land
                if (currentBagEl) currentBagEl.remove();
                if (currentBagShadowEl) currentBagShadowEl.remove();
                finishThrow();
              }
            }
          }

          animationFrameId = requestAnimationFrame(animate);
        }

        function createTrailParticle(x, y, z) {
          const p = document.createElement('div');
          p.className = 'trail-particle';
          p.style.background = localPlayerNum === 1 ? player1Color : player2Color;
          p.style.boxShadow = `0 0 8px ${localPlayerNum === 1 ? player1Color : player2Color}`;
          p.style.transform = `translate3d(${x - 4}px, ${y - 4}px, ${z - 10}px)`;
          p.style.zIndex = '400';
          
          if (trajectoryContainer) {
            trajectoryContainer.appendChild(p);
            setTimeout(() => {
              if (p && p.parentNode) {
                p.remove();
              }
            }, 600);
          }
        }

        // Enhanced scoring system with visual effects
        async function registerScore(x, y, rotation, isInHole) {
          // Use a unique variable name to avoid conflicts
          const playerStr = `player${localPlayerNum}`;
          
          // Prepare bag data object
          const bagData = {
            x: x,
            y: y,
            isInHole: isInHole,
            rotation: rotation,
            timestamp: Date.now()
          };
          
          // Update Firebase
          try {
            const gameRef = db.collection('cornholeGames').doc(gameId);
            const doc = await gameRef.get();
            
            if (!doc.exists) {
              console.error("Game document not found");
              finishThrow();
              return;
            }
            
            const currentBags = doc.data().bagsInPlay[playerStr] || [];
            console.log(`Bag scored: ${isInHole ? 'In hole (3 pts)' : 'On board (1 pt)'}`);
            
            try {
              await gameRef.update({
                [`bagsInPlay.${playerStr}`]: [...currentBags, bagData]
              });
            } catch (updateError) {
              console.error("Error updating bag position:", updateError);
            }
          } catch (err) {
            console.error("Error registering score:", err);
          }
          
          // Finish throw after delay
          setTimeout(() => {
            finishThrow();
          }, 300);
        }

        function createHoleInEffect(x, y) {
          // Create particle effects for successful hole-in shots
          for (let i = 0; i < 20; i++) {
            const particle = document.createElement('div');
            particle.className = 'trail-particle';
            particle.style.background = localPlayerNum === 1 ? player1Color : player2Color;
            particle.style.animation = 'fadeOut 1s forwards';
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            particle.style.zIndex = '1000'; // Ensure particles are visible

            const angle = (i / 20) * Math.PI * 2;
            const velocity = 2;
            const vx = Math.cos(angle) * velocity;
            const vy = Math.sin(angle) * velocity;

            particle.style.transform = `translate(${vx * 20}px, ${vy * 20}px)`;
            trajectoryContainer.appendChild(particle);

            setTimeout(() => {
              if (particle && particle.parentNode) {
                particle.remove();
              }
            }, 1000);
          }
        }

        // Improved turn management with error handling
        async function finishThrow() {
          const gameRef = db.collection('cornholeGames').doc(gameId);

          try {
            // Clear current bag references (actual elements are kept for display)
            currentBagEl = null;
            currentBagShadowEl = null;
            
            // Get the latest game state
            const doc = await gameRef.get();
            if (!doc.exists) {
              console.error("Game document not found");
              return;
            }
            
            const data = doc.data();
            
            if (localPlayerNum === 1) {
              // Calculate the new throw count
              const newThrowCount = player1Throws + 1;
              console.log(`Player 1 completed throw ${newThrowCount} of ${totalThrows}`);
              
              // Update throw count and switch to player 2
              try {
                await gameRef.update({
                  player1Throws: newThrowCount,
                  currentPlayer: 2 // Always switch to player 2 after player 1's throw
                });
                console.log("Successfully switched to Player 2's turn");
              } catch (updateError) {
                console.error("Error switching turns:", updateError);
                // If Firebase update fails, still update local state
                player1Throws = newThrowCount;
                currentPlayer = 2;
                updateTryCounter();
              }

              // Check if round is complete
              try {
                const updatedDoc = await gameRef.get();
                if (!updatedDoc.exists) return;
                
                const updatedData = updatedDoc.data();
                if (newThrowCount >= totalThrows && updatedData.player2Throws >= totalThrows) {
                  await calculateAndUpdateScore();
                }
              } catch (checkError) {
                console.error("Error checking round completion:", checkError);
              }
            } else { // localPlayerNum === 2
              // Calculate the new throw count
              const newThrowCount = player2Throws + 1;
              console.log(`Player 2 completed throw ${newThrowCount} of ${totalThrows}`);
              
              // Update throw count and switch to player 1
              try {
                await gameRef.update({
                  player2Throws: newThrowCount,
                  currentPlayer: 1 // Always switch to player 1 after player 2's throw
                });
                console.log("Successfully switched to Player 1's turn");
              } catch (updateError) {
                console.error("Error switching turns:", updateError);
                // If Firebase update fails, still update local state
                player2Throws = newThrowCount;
                currentPlayer = 1;
                updateTryCounter();
              }

              // Check if round is complete
              try {
                const updatedDoc = await gameRef.get();
                if (!updatedDoc.exists) return;
                
                const updatedData = updatedDoc.data();
                if (updatedData.player1Throws >= totalThrows && newThrowCount >= totalThrows) {
                  await calculateAndUpdateScore();
                }
              } catch (checkError) {
                console.error("Error checking round completion:", checkError);
              }
            }
          } catch (err) {
            console.error("Error updating game state:", err);
            // Update local state to prevent UI from being stuck
            if (localPlayerNum === 1) {
              player1Throws++;
              currentPlayer = 2;
            } else {
              player2Throws++;
              currentPlayer = 1;
            }
            updateTryCounter();
          }
        }

        // Proper cornhole scoring with cancellation rules
        async function calculateAndUpdateScore() {
          const gameRef = db.collection('cornholeGames').doc(gameId);
          try {
            const doc = await gameRef.get();
            if (!doc.exists) {
              console.error("Game document not found");
              return;
            }
            
            const data = doc.data();

            // Calculate scores with proper cancellation rules
            const p1Bags = data.bagsInPlay.player1 || [];
            const p2Bags = data.bagsInPlay.player2 || [];

            // Count bags in hole and on board
            const p1InHole = p1Bags.filter(b => b.isInHole).length;
            const p2InHole = p2Bags.filter(b => b.isInHole).length;
            const p1OnBoard = p1Bags.filter(b => !b.isInHole).length;
            const p2OnBoard = p2Bags.filter(b => !b.isInHole).length;

            // Calculate raw points
            const p1Points = (p1InHole * POINTS_IN_HOLE) + (p1OnBoard * POINTS_ON_BOARD);
            const p2Points = (p2InHole * POINTS_IN_HOLE) + (p2OnBoard * POINTS_ON_BOARD);

            // Log the scoring calculation
            console.log(`Round summary:
              Player 1: ${p1InHole} in hole (${p1InHole * 3} pts) + ${p1OnBoard} on board (${p1OnBoard} pts) = ${p1Points} pts
              Player 2: ${p2InHole} in hole (${p2InHole * 3} pts) + ${p2OnBoard} on board (${p2OnBoard} pts) = ${p2Points} pts`);

            // Apply cancellation rules - only the difference in points is awarded
            const netPoints = Math.abs(p1Points - p2Points);
            const winner = p1Points > p2Points ? 1 : (p1Points < p2Points ? 2 : 0);

            // Update scores
            const oldScores = {...gameScores};
            if (winner === 1) {
              gameScores.player1 += netPoints;
              console.log(`Player 1 wins the round and gets ${netPoints} points`);
            } else if (winner === 2) {
              gameScores.player2 += netPoints;
              console.log(`Player 2 wins the round and gets ${netPoints} points`);
            } else {
              console.log(`The round is a tie, no points awarded`);
            }

            console.log(`Score update: ${oldScores.player1}-${oldScores.player2} → ${gameScores.player1}-${gameScores.player2}`);

            try {
              // Check for game end
              if (gameScores.player1 >= WINNING_SCORE || gameScores.player2 >= WINNING_SCORE) {
                await gameRef.update({
                  gameStatus: 'ended',
                  gameScores: gameScores
                });
                console.log(`Game over. Final score: ${gameScores.player1}-${gameScores.player2}`);
              } else {
                // Start new round with clean state
                await gameRef.update({
                  player1Throws: 0,
                  player2Throws: 0,
                  currentPlayer: 1, // Player 1 starts each new round
                  gameScores: gameScores,
                  bagsInPlay: {
                    player1: [],
                    player2: []
                  }
                });
                console.log(`Starting new round. Current score: ${gameScores.player1}-${gameScores.player2}`);
              }
            } catch (err) {
              console.error("Error updating score:", err);
            }
          } catch (err) {
            console.error("Error calculating score:", err);
          }
        }

        function updateTryCounter() {
          const myThrows = localPlayerNum === 1 ? player1Throws : player2Throws;
          const myTotal = totalThrows;
          
          if (currentPlayer === localPlayerNum) {
            tryCounterEl.textContent = `Your turn - Throw ${myThrows + 1} of ${myTotal}`;
          } else {
            const opponentThrows = currentPlayer === 1 ? player1Throws : player2Throws;
            tryCounterEl.textContent = `Opponent's turn - Throw ${opponentThrows + 1} of ${totalThrows}`;
          }
        }

        function updateScoreDisplay() {
          scoreDisplayEl.textContent =
            `Score - Player 1: ${gameScores.player1} | Player 2: ${gameScores.player2}`;
        }

        function showResult() {
          const winner = gameScores.player1 > gameScores.player2 ? 1 : 
                        (gameScores.player1 < gameScores.player2 ? 2 : 0);
          const resultMessage = winner === localPlayerNum ? "You win!" : 
                              (winner === 0 ? "It's a tie!" : "You lose!");

          document.getElementById("resultMessage").textContent =
            `${resultMessage} Final Score: Player 1: ${gameScores.player1} - Player 2: ${gameScores.player2}`;
          showScreen("resultScreen");
        }

        function resetGame() {
          const gameRef = db.collection('cornholeGames').doc(gameId);

          gameRef.update({
            player1Throws: 0,
            player2Throws: 0,
            currentPlayer: 1,
            gameStatus: 'started',
            gameScores: { player1: 0, player2: 0 },
            bagsInPlay: { player1: [], player2: [] }
          }).then(() => {
            document.querySelectorAll('.bag, .bag-shadow').forEach(bag => {
              if (bag) bag.remove();
            });
            showScreen("gameScreen");
          }).catch((error) => {
            console.error("Error resetting game: ", error);
          });
        }

        // Event Listeners
        gameScreenEl.addEventListener('mousedown', startDrag);
        gameScreenEl.addEventListener('mousemove', updateDrag);
        gameScreenEl.addEventListener('mouseup', endDrag);
        gameScreenEl.addEventListener('mouseleave', endDrag);
        gameScreenEl.addEventListener('touchstart', startDrag);
        gameScreenEl.addEventListener('touchmove', updateDrag);
        gameScreenEl.addEventListener('touchend', endDrag);

        document.getElementById('create-game').addEventListener('click', createNewGame);
        document.getElementById('join-game').addEventListener('click', () => {
          joinGame(document.getElementById('gameIdInput').value.trim());
        });
        document.getElementById('restart-game').addEventListener('click', resetGame);

        // Window resize handler
        window.addEventListener('resize', () => {
          if (currentBagEl) {
            setBagStartPosition();
          }
        });

        // Helper function for generating player ID
        function generatePlayerId() {
          let stored = localStorage.getItem('playerId');
          if (stored) return stored;
          let newId = Math.random().toString(36).substr(2, 9);
          localStorage.setItem('playerId', newId);
          return newId;
        }

        // Auto-join from URL
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has("gameId")) {
          joinGame(urlParams.get("gameId"));
        }
      } catch (error) {
        console.error("Error initializing app:", error);
        showFirebaseError();
      }
    }

    // Check if Firebase is loaded and initialize the app
    window.addEventListener('load', function() {
      if (isFirebaseLoaded()) {
        initializeApp();
      } else {
        showFirebaseError();
      }
    });
  </script>
</body>
</html>
