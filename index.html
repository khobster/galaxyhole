<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Space Cornhole — Multiplayer v2</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    html, body {
      height: 100%;
      font-family: system-ui, Segoe UI, Roboto, sans-serif;
      background: linear-gradient(#87CEEB 0%, #90EE90 100%);
      overflow: hidden;
    }
    
    h1 {
      color: #333;
      margin-bottom: 1.5rem;
      text-shadow: 1px 1px 3px rgba(255, 255, 255, 0.7);
    }
    
    .screen {
      position: absolute;
      inset: 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1.5rem;
      padding: 2rem;
      transition: opacity 0.3s ease;
    }
    
    #setup {
      display: flex;
    }
    
    button {
      padding: 0.6rem 1.2rem;
      border: none;
      border-radius: 0.5rem;
      font-weight: 600;
      color: #fff;
      background: #c41e3a;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transition: background 0.2s, transform 0.1s;
      white-space: nowrap;
    }
    
    button:hover {
      background: #d42e4a;
      transform: translateY(-2px);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    label {
      font-weight: 500;
      margin-bottom: 0.5rem;
      display: block;
    }
    
    select, input {
      padding: 0.5rem 1rem;
      border: 2px solid #444;
      border-radius: 0.4rem;
      font: inherit;
      width: 100%;
      margin-top: 0.25rem;
    }
    
    .input-group {
      width: 300px;
      margin-bottom: 1rem;
    }
    
    #board {
      position: absolute;
      width: 120px;
      height: 200px;
      left: 50%;
      top: 30%; /* Moved higher up on screen to show proper perspective */
      transform: translate(-50%, -50%);
      background: #8B4513;
      border: 8px solid #654321;
      border-radius: 8px;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
    }
    
    #hole {
      position: absolute;
      width: 35px;
      height: 35px;
      left: 50%;
      top: 20%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: #000;
      box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
    }
    
    .bag {
      position: absolute;
      width: 35px;
      height: 35px;
      border-radius: 5px;
      background: var(--clr);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25);
      will-change: transform;
      z-index: 10;
    }
    
    .shadow {
      position: absolute;
      width: 35px;
      height: 12px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.2);
      will-change: transform;
      pointer-events: none;
    }
    
    #hud {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.3rem;
      padding: 1rem;
      pointer-events: none;
      z-index: 20;
    }
    
    #planet {
      background: rgba(255, 255, 255, 0.8);
      padding: 0.3rem 0.8rem;
      border-radius: 0.4rem;
      font-weight: 600;
      pointer-events: auto;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      margin-bottom: 0.3rem;
    }
    
    #scoreAndTurn {
      display: flex;
      align-items: center;
      gap: 1rem;
      background: rgba(255, 255, 255, 0.8);
      padding: 0.3rem 0.8rem;
      border-radius: 0.4rem;
      font-weight: 600;
      pointer-events: auto;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    
    #throws {
      background: rgba(255, 255, 255, 0.8);
      padding: 0.3rem 0.8rem;
      border-radius: 0.4rem;
      font-weight: 600;
      pointer-events: auto;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      margin-top: 0.3rem;
    }
    
    #waitMsg {
      font-weight: 500;
      color: #333;
    }
    
    #result h2 {
      color: #333;
      text-shadow: 1px 1px 3px rgba(255, 255, 255, 0.7);
    }
    
    .link-container {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    
    #link {
      width: 340px;
    }
    
    .waiting-animation {
      display: inline-block;
      position: relative;
      width: 80px;
      height: 12px;
    }
    
    .waiting-animation div {
      position: absolute;
      top: 0;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #c41e3a;
      animation-timing-function: cubic-bezier(0, 1, 1, 0);
    }
    
    .waiting-animation div:nth-child(1) {
      left: 8px;
      animation: waiting1 1s infinite;
    }
    
    .waiting-animation div:nth-child(2) {
      left: 8px;
      animation: waiting2 1s infinite;
    }
    
    .waiting-animation div:nth-child(3) {
      left: 32px;
      animation: waiting2 1s infinite;
    }
    
    .waiting-animation div:nth-child(4) {
      left: 56px;
      animation: waiting3 1s infinite;
    }
    
    @keyframes waiting1 {
      0% { transform: scale(0); }
      100% { transform: scale(1); }
    }
    
    @keyframes waiting2 {
      0% { transform: translate(0, 0); }
      100% { transform: translate(24px, 0); }
    }
    
    @keyframes waiting3 {
      0% { transform: scale(1); }
      100% { transform: scale(0); }
    }
    
    #instructions {
      background: rgba(255, 255, 255, 0.8);
      padding: 1rem;
      border-radius: 0.5rem;
      margin-top: 1rem;
      max-width: 400px;
      font-size: 0.9rem;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <div id="setup" class="screen">
    <h1>Space Cornhole</h1>
    <div class="input-group">
      <label for="planetSel">Select Gravity:</label>
      <select id="planetSel">
        <option value="earth">Earth (9.8)</option>
        <option value="moon">Moon (1.6)</option>
        <option value="mars">Mars (3.7)</option>
        <option value="jupiter">Jupiter (24.8)</option>
      </select>
    </div>
    <button id="create">Create New Game</button>
    <div class="input-group">
      <label for="joinId">Join Existing Game:</label>
      <input id="joinId" placeholder="Enter Game ID" />
    </div>
    <button id="join">Join Game</button>
    
    <div id="instructions">
      <p><strong>How to play:</strong> Drag and release to throw your bean bags toward the board. 
      Score 1 point for landing on the board, 3 points for getting in the hole. 
      First to 21 points wins!</p>
    </div>
  </div>

  <div id="wait" class="screen">
    <h2>Game Created!</h2>
    <p>Share this link with your opponent:</p>
    <div class="link-container">
      <input id="link" readonly />
      <button id="copy">Copy</button>
    </div>
    <p id="waitMsg">Waiting for opponent to join...</p>
    <div class="waiting-animation"><div></div><div></div><div></div><div></div></div>
  </div>

  <div id="game" class="screen">
    <div id="hud">
      <div id="planet"></div>
      <div id="scoreAndTurn">
        <div id="scores">0 – 0</div>
        <div id="turn"></div>
      </div>
      <div id="throws"></div>
    </div>
    <div id="board"><div id="hole"></div></div>
  </div>

  <div id="result" class="screen">
    <h2 id="msg"></h2>
    <button id="again">Play Again</button>
  </div>

<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
<script>
// ── Firebase config (keep as‑is) ────────────────────────────────────────────────
const firebaseConfig = {
  apiKey: "AIzaSyBMuOpUCgNHUkccH_ENPE9l-iQApvdHtA4",
  authDomain: "galaxy-hole-53c76.firebaseapp.com",
  projectId: "galaxy-hole-53c76",
  storageBucket: "galaxy-hole-53c76.appspot.com",
  messagingSenderId: "592610380036",
  appId: "1:592610380036:web:4b5c72ee181682b9262851"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// ── Physics presets ────────────────────────────────────────────────────────────
const planets = {
  earth: { g: 9.8, scale: 1, name: "Earth" },
  moon: { g: 1.6, scale: 0.45, name: "Moon" },
  mars: { g: 3.7, scale: 0.7, name: "Mars" },
  jupiter: { g: 24.8, scale: 1.4, name: "Jupiter" }
};
let planet = planets.earth;

// ── Basic state ────────────────────────────────────────────────────────────────
let gameId = null;
let me = null;
let turn = 1;
let throws = { 1: 0, 2: 0 };
let score = { 1: 0, 2: 0 };
const MAX = 4;  // Maximum throws per player per round
const WIN = 21; // Score needed to win
const pid = (() => {
  let v = localStorage.pid;
  if (!v) {
    v = Math.random().toString(36).slice(2, 9);
    localStorage.pid = v;
  }
  return v;
})();

// ── DOM helpers ────────────────────────────────────────────────────────────────
const $ = id => document.getElementById(id);
const screens = {
  setup: $('setup'),
  wait: $('wait'),
  game: $('game'),
  result: $('result')
};

const show = scr => {
  Object.values(screens).forEach(s => {
    s.style.display = s === scr ? 'flex' : 'none';
    // Add a small animation
    if (s === scr) {
      s.style.opacity = 0;
      setTimeout(() => s.style.opacity = 1, 10);
    }
  });
};

show(screens.setup);

// ── UI actions ────────────────────────────────────────────────────────────────
$('planetSel').onchange = e => planet = planets[e.target.value];
$('copy').onclick = () => {
  navigator.clipboard.writeText($('link').value);
  $('copy').textContent = "Copied!";
  setTimeout(() => $('copy').textContent = "Copy", 2000);
};
$('again').onclick = () => location.href = location.pathname;

$('create').onclick = async () => {
  try {
    const doc = await db.collection('cornhole').add({
      p1: pid,
      p2: null,
      planet: $('planetSel').value,
      st: 'wait',
      turn: 1,
      sc: { 1: 0, 2: 0 },
      th: { 1: 0, 2: 0 },
      bags: { 1: [], 2: [] }
    });
    gameId = doc.id;
    me = 1;
    planet = planets[$('planetSel').value];
    $('link').value = `${location.origin}${location.pathname}?id=${gameId}`;
    show(screens.wait);
    listen();
  } catch (err) {
    alert(`Error creating game: ${err.message}`);
  }
};

$('join').onclick = () => join($('joinId').value.trim());

async function join(id) {
  if (!id) {
    alert("Please enter a Game ID");
    return;
  }
  
  try {
    gameId = id;
    me = 2;
    const ref = db.collection('cornhole').doc(id);
    const snap = await ref.get();
    
    if (!snap.exists) {
      alert('Game not found. Please check the ID and try again.');
      return;
    }
    
    const d = snap.data();
    if (d.p2 && d.p2 !== pid) {
      alert('This game is already full. Please create a new game or join a different one.');
      return;
    }
    
    await ref.update({
      p2: pid,
      st: 'play'
    });
    
    listen();
    show(screens.game);
  } catch (err) {
    alert(`Error joining game: ${err.message}`);
  }
}

// Check for game ID in URL params
const qp = new URLSearchParams(location.search);
if (qp.has('id')) join(qp.get('id'));

// ── Firestore listener ────────────────────────────────────────────────────────
function listen() {
  const unsubscribe = db.collection('cornhole').doc(gameId).onSnapshot(snap => {
    if (!snap.exists) {
      alert("Game no longer exists.");
      location.href = location.pathname;
      return;
    }
    
    const d = snap.data();
    const planetKey = d.planet || 'earth';
    planet = planets[planetKey];
    turn = d.turn;
    throws = d.th;
    score = d.sc;
    updateUI(d.st, d.bags);
  }, error => {
    console.error("Firestore listening error:", error);
    alert(`Connection error: ${error.message}`);
  });
  
  // Cleanup listener on page unload
  window.addEventListener('beforeunload', unsubscribe);
}

// ── UI refresh ────────────────────────────────────────────────────────────────
function updateUI(st, bags) {
  $('scores').textContent = `${score[1]} – ${score[2]}`;
  $('turn').textContent = turn === me ? 'Your turn' : 'Opponent\'s turn';
  $('throws').textContent = `Throws: ${throws[1]}/${MAX} - ${throws[2]}/${MAX}`;
  
  const planetName = planet ? planet.name || Object.keys(planets).find(k => planets[k] === planet) : 'Earth';
  $('planet').textContent = `Gravity: ${planetName}`;
  
  if (st === 'wait') {
    show(me === 1 ? screens.wait : screens.game);
  } else if (st === 'play') {
    show(screens.game);
    if (turn === me && throws[me] < MAX) {
      // Only spawn a new bag if one isn't already active
      if (!document.querySelector('.bag')) {
        spawnBag();
      }
    }
  } else if (st === 'end') {
    show(screens.result);
    $('msg').textContent = score[me] > score[3-me] ? 'You win!' : 'You lose!';
  }
}

// ── BAG DRAG & THROW ──────────────────────────────────────────────────────────
let bag, shadow, start, isDragging = false;
let dragStartX, dragStartY;
let aimLine;

function spawnBag() {
  // Remove any existing bags first to prevent duplicates
  const existingBags = document.querySelectorAll('.bag, .shadow');
  existingBags.forEach(el => el.remove());
  
  // Remove aim line if it exists
  if (aimLine) aimLine.remove();
  
  bag = document.createElement('div');
  bag.className = 'bag';
  bag.style.setProperty('--clr', me === 1 ? '#c41e3a' : '#4287f5');
  
  shadow = document.createElement('div');
  shadow.className = 'shadow';
  
  document.body.append(bag, shadow);
  
  // Position at bottom center - player's perspective
  const startX = innerWidth/2-17;
  const startY = innerHeight-60; // Higher up from bottom for better perspective
  bag.style.transform = `translate(${startX}px,${startY}px) scale(0.8)`;
  shadow.style.transform = `translate(${startX}px,${startY+10}px) scale(0.8)`;
  
  // Add a small animation for appearance
  setTimeout(() => {
    bag.style.transition = 'transform 0.3s ease';
    shadow.style.transition = 'transform 0.3s ease';
    bag.style.transform = `translate(${startX}px,${startY}px) scale(1)`;
    shadow.style.transform = `translate(${startX}px,${startY+10}px) scale(1)`;
    
    // Add event listeners after animation
    setTimeout(() => {
      bag.style.transition = '';
      shadow.style.transition = '';
      document.addEventListener('pointerdown', dragStart);
    }, 300);
  }, 50);
}

function dragStart(e) {
  // Prevent drag if it's not our turn
  if (turn !== me) return;
  
  // Prevent default to avoid text selection
  e.preventDefault();
  
  isDragging = true;
  
  // Get position of the bag for drag calculation
  const bagRect = bag.getBoundingClientRect();
  dragStartX = e.clientX;
  dragStartY = e.clientY;
  
  // Starting position - center of the bag
  start = {
    x: bagRect.left + bagRect.width/2,
    y: bagRect.top + bagRect.height/2,
    t: performance.now()
  };
  
  // Create aim line
  aimLine = document.createElement('div');
  aimLine.style.position = 'absolute';
  aimLine.style.height = '2px';
  aimLine.style.backgroundColor = me === 1 ? 'rgba(255, 100, 100, 0.7)' : 'rgba(100, 100, 255, 0.7)';
  aimLine.style.transformOrigin = 'center bottom';
  aimLine.style.zIndex = '5';
  aimLine.style.pointerEvents = 'none';
  document.body.appendChild(aimLine);
  
  document.addEventListener('pointermove', dragMove);
  document.addEventListener('pointerup', dragEnd);
  document.addEventListener('pointercancel', dragEnd);
}

function dragMove(e) {
  if (!isDragging) return;
  
  // Calculate drag distance and direction
  const dx = e.clientX - dragStartX;
  const dy = e.clientY - dragStartY;
  
  // Calculate angle and distance for aim line
  const angle = Math.atan2(dy, dx);
  const distance = Math.hypot(dx, dy);
  
  // Draw aim line (opposite direction of drag = direction of throw)
  aimLine.style.width = `${Math.min(distance * 1.5, 150)}px`;
  aimLine.style.left = `${start.x}px`;
  aimLine.style.top = `${start.y}px`;
  aimLine.style.transform = `rotate(${angle}rad) translateY(-1px)`;
  
  // Move bag slightly in drag direction (rubber band effect)
  const dragFactor = 0.2; // How much the bag "stretches" when dragged
  const moveX = dx * dragFactor;
  const moveY = dy * dragFactor;
  
  bag.style.transform = `translate(${start.x + moveX - 17}px, ${start.y + moveY - 17}px)`;
  shadow.style.transform = `translate(${start.x + moveX - 17}px, ${start.y + moveY + 10 - 17}px)`;
}

function dragEnd(e) {
  if (!isDragging) return;
  
  document.removeEventListener('pointermove', dragMove);
  document.removeEventListener('pointerup', dragEnd);
  document.removeEventListener('pointercancel', dragEnd);
  
  // Remove aim line
  if (aimLine) {
    aimLine.remove();
    aimLine = null;
  }
  
  // Calculate the drag vector - important for determining throw direction and power
  const dx = e.clientX - dragStartX;
  const dy = e.clientY - dragStartY;
  const dragDistance = Math.hypot(dx, dy);
  
  // If barely moved, reset the bag
  if (dragDistance < 15) {
    isDragging = false;
    spawnBag(); // Reset the bag for a new throw
    return;
  }
  
  // Calculate initial velocity based on drag
  // Using a negative value means pulling down will throw up (natural feel)
  const powerFactor = 5;
  const angle = Math.atan2(dy, dx);
  
  // Convert drag to initial velocity
  // We reverse the angle to make it feel natural (pull back = throw forward)
  const initialVelocity = dragDistance * powerFactor / 30;
  const initialAngle = angle + Math.PI; // Reverse direction
  
  // Calculate velocity components
  const vx = initialVelocity * Math.cos(initialAngle);
  const vy = initialVelocity * Math.sin(initialAngle);
  
  // Start the parabolic throw animation with these initial conditions
  throwBagParabolic(vx, vy);
  isDragging = false;
}

function throwBag(velocityX, velocityY, velocityZ) {
  // Get starting position from the current bag position
  const bagStyle = window.getComputedStyle(bag);
  const matrix = new DOMMatrix(bagStyle.transform);
  const sx = matrix.m41;
  const sy = matrix.m42;
  
  // Physics constants based on planet
  const gravityBase = 0.2; 
  const gravity = planet.g * gravityBase; // Scale gravity based on planet
  
  // Add some visual feedback on throw start
  bag.style.transition = 'transform 0.1s ease';
  bag.style.transform = `translate(${sx}px, ${sy}px) scale(1.2)`;
  
  setTimeout(() => {
    bag.style.transition = '';
    
    // Animation state
    let lastTime = performance.now();
    let posX = sx;
    let posY = sy;
    let velX = velocityX;
    let velY = velocityY;
    let velZ = velocityZ;
    
    // Z position (towards/away from screen)
    let posZ = 0; // Start at screen plane
    
    // Bag scale for perspective effect (smaller as it moves away)
    let scale = 1.0;
    
    let landed = false;
    
    // Animation loop
    function animate(now) {
      if (landed) return;
      
      // Time delta in seconds
      const deltaTime = (now - lastTime) / 1000;
      lastTime = now;
      
      // Apply physics
      velY += gravity * deltaTime * 60; // Gravity affects vertical velocity
      
      // Update position based on velocity
      posX += velX * deltaTime * 15;
      posY += velY * deltaTime * 15;
      posZ += velZ * deltaTime * 15; // Move forward/backward
      
      // Perspective scaling - bag gets smaller as it moves away (up the screen)
      scale = Math.max(0.3, 1.0 - (posZ / -1000));
      
      // Calculate screen position with perspective
      // As Z becomes more negative (further away), Y position moves higher on screen
      const screenY = posY + (posZ * 0.5); // Perspective factor
      
      // Update visual position with scale for perspective
      bag.style.transform = `translate(${posX}px, ${screenY}px) scale(${scale})`;
      
      // Calculate shadow position and scale based on height and Z-depth
      const groundY = innerHeight - 20;
      const heightAboveGround = Math.max(0, groundY - screenY);
      
      // Calculate shadow scale - considers both height and Z distance
      // Shadow gets smaller as bag goes higher or further away
      const shadowScale = Math.max(0.1, scale * (1 - heightAboveGround / 500));
      
      // Shadow offset based on perspective and height
      const shadowX = posX + (heightAboveGround * 0.1);
      shadow.style.transform = `translate(${shadowX}px, ${groundY}px) scale(${shadowScale})`;
      
      // Check if the bag has reached the cornhole board's Z position
      if (posZ <= -500) { // Board is somewhere in the distance
        // Board position in the screen frame
        const br = document.getElementById('board').getBoundingClientRect();
        const hr = document.getElementById('hole').getBoundingClientRect();
        
        // Check if the bag would hit the board based on X/Y position
        const bagCenterX = posX + 17 * scale;
        const bagCenterY = screenY + 17 * scale;
        
        // Distance to hole center
        const holeCenterX = hr.left + hr.width/2;
        const holeCenterY = hr.top + hr.height/2;
        const distanceToHole = Math.hypot(bagCenterX - holeCenterX, bagCenterY - holeCenterY);
        
        // Did we hit the hole?
        if (distanceToHole < hr.width/2) {
          landed = true;
          
          // Special animation for hole-in-one!
          bag.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
          bag.style.transform = `translate(${holeCenterX - 17 * scale}px, ${holeCenterY - 17 * scale}px) scale(${scale * 0.1})`;
          bag.style.opacity = '0.2';
          shadow.style.transition = 'opacity 0.2s ease';
          shadow.style.opacity = '0';
          
          // Score points after animation
          setTimeout(() => {
            bag.remove();
            shadow.remove();
            finishThrow(3); // 3 points for in the hole
          }, 300);
          
          return;
        }
        
        // Did we hit the board?
        if (bagCenterX > br.left && bagCenterX < br.right && 
            bagCenterY > br.top && bagCenterY < br.bottom) {
          
          landed = true;
          
          // Land on the board animation
          bag.style.transition = 'transform 0.1s ease';
          
          // Position bag on the board surface
          bag.style.transform = `translate(${posX}px, ${bagCenterY}px) scale(${scale})`;
          
          // Score after landing animation
          setTimeout(() => {
            finishThrow(1); // 1 point for on the board
            
            // Fade out after scoring
            bag.style.transition = 'opacity 0.5s ease';
            shadow.style.transition = 'opacity 0.5s ease';
            bag.style.opacity = '0.7';
            shadow.style.opacity = '0';
            
            setTimeout(() => {
              bag.remove();
              shadow.remove();
            }, 800);
            
          }, 300);
          
          return;
        }
      }
      
      // Check if we've gone too far (missed the board)
      if (posZ < -800) {
        landed = true;
        
        // Fade out animation
        bag.style.transition = 'opacity 0.3s ease';
        shadow.style.transition = 'opacity 0.3s ease';
        bag.style.opacity = '0';
        shadow.style.opacity = '0';
        
        setTimeout(() => {
          bag.remove();
          shadow.remove();
          finishThrow(0); // Miss
        }, 300);
        
        return;
      }
      
      // Continue animation
      requestAnimationFrame(animate);
    }
    
    // Start animation
    requestAnimationFrame(animate);
  }, 100);
}

function finishThrow(points) {
  // Update the game state in Firebase
  db.runTransaction(async tx => {
    try {
      const ref = db.collection('cornhole').doc(gameId);
      const snap = await tx.get(ref);
      
      if (!snap.exists) {
        throw new Error("Game doesn't exist anymore");
      }
      
      const d = snap.data();
      
      // Initialize bags array if it doesn't exist
      if (!d.bags) d.bags = { 1: [], 2: [] };
      if (!d.bags[me]) d.bags[me] = [];
      
      // Add the throw result
      d.bags[me].push({ pts: points });
      
      // Create a visual feedback element for points
      showPointsFeedback(points);
      
      // Increment throw counter
      d.th[me]++;
      
      // Check if round is complete
      if (d.th[1] >= MAX && d.th[2] >= MAX) {
        scoreRound(d);
      } else {
        // Switch turns
        d.turn = 3 - d.turn;
      }
      
      d.st = 'play';
      
      tx.set(ref, d);
    } catch (err) {
      console.error("Error in transaction:", err);
      alert(`Game error: ${err.message}`);
    }
  });
}

function showPointsFeedback(points) {
  // Create point indicator
  const pointsEl = document.createElement('div');
  pointsEl.style.position = 'absolute';
  pointsEl.style.top = '40%';
  pointsEl.style.left = '50%';
  pointsEl.style.transform = 'translate(-50%, -50%) scale(0)';
  pointsEl.style.fontSize = '64px';
  pointsEl.style.fontWeight = 'bold';
  pointsEl.style.color = 'white';
  pointsEl.style.textShadow = '0 0 10px rgba(0,0,0,0.5)';
  pointsEl.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
  pointsEl.style.opacity = '0';
  pointsEl.style.zIndex = '100';
  
  if (points === 3) {
    pointsEl.textContent = '+3!';
    pointsEl.style.color = '#FFD700';
  } else if (points === 1) {
    pointsEl.textContent = '+1';
    pointsEl.style.color = '#FFFFFF';
  } else {
    pointsEl.textContent = 'Miss';
    pointsEl.style.color = '#FF5555';
  }
  
  document.body.appendChild(pointsEl);
  
  // Animate
  setTimeout(() => {
    pointsEl.style.opacity = '1';
    pointsEl.style.transform = 'translate(-50%, -50%) scale(1)';
    
    setTimeout(() => {
      pointsEl.style.opacity = '0';
      pointsEl.style.transform = 'translate(-50%, -100%) scale(0.8)';
      
      setTimeout(() => {
        pointsEl.remove();
      }, 300);
    }, 800);
  }, 10);
}

function scoreRound(d) {
  // Calculate points for each player
  const p1 = d.bags[1].reduce((s, b) => s + b.pts, 0);
  const p2 = d.bags[2].reduce((s, b) => s + b.pts, 0);
  
  // Calculate the difference in points (cancellation scoring)
  const diff = Math.abs(p1 - p2);
  
  // Award points to the winner of the round
  if (p1 > p2) {
    d.sc[1] += diff;
  } else if (p2 > p1) {
    d.sc[2] += diff;
  }
  
  // Reset for next round
  d.bags = { 1: [], 2: [] };
  d.th = { 1: 0, 2: 0 };
  
  // Player 1 always starts new rounds
  d.turn = 1;
  
  // Check for win condition
  if (d.sc[1] >= WIN || d.sc[2] >= WIN) {
    d.st = 'end';
  }
}
</script>
</body>
</html>
