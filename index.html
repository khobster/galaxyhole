async function registerScore(x, y, rotation) {
      const boardCenter = window.innerWidth / 2;
      const distanceFromHole = Math.sqrt(
        Math.pow(x - boardCenter, 2) +
        Math.pow(y - (boardTop + 30 / 2), 2)
      );

      // Increased hole radius for better playability
      const isInHole = distanceFromHole <= HOLE_RADIUS;
      const currentPlayerStr = `player${localPlayerNum}`;

      // Store bag data with timestamp for persistence
      const bagData = {
        x: x,
        y: y,
        isInHole: isInHole,
        rotation: rotation,
        timestamp: Date.now()
      };

      try {
        // Update Firebase with new bag position
        const gameRef = db.collection('cornholeGames').doc(gameId);
        const doc = await gameRef.get();
        const currentBags = doc.data().bagsInPlay[currentPlayerStr] || [];
        
        await gameRef.update({
          [`bagsInPlay.${currentPlayerStr}`]: [...currentBags, bagData]
        });

        if (isInHole) {
          createHoleInEffect(x, y);
        }
        
        // Wait before finishing throw to ensure animation completes
        setTimeout(() => {
          finishThrow();
        }, 300);
      } catch (err) {
        console.error("Error registering score:", err);
      }
    }

    function createHoleInEffect(x, y) {
      // Create particle effects for successful hole-in shots
      for (let i = 0; i < 20; i++) {
        const particle = document.createElement('div');
        particle.className = 'trail-particle';
        particle.style.background = localPlayerNum === 1 ? player1Color : player2Color;
        particle.style.animation = 'fadeOut 1s forwards';
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;

        const angle = (i / 20) * Math.PI * 2;
        const velocity = 2;
        const vx = Math.cos(angle) * velocity;
        const vy = Math.sin(angle) * velocity;

        particle.style.transform = `translate(${vx * 20}px, ${vy * 20}px)`;
        trajectoryContainer.appendChild(particle);

        setTimeout(() => particle.remove(), 1000);
      }
    }

    // Improved turn management with proper switching
    async function finishThrow() {
      const gameRef = db.collection('cornholeGames').doc(gameId);

      try {
        // Immediately update our local state
        currentBagEl = null;
        
        // First get the latest game state
        const doc = await gameRef.get();
        const data = doc.data();
        
        if (localPlayerNum === 1) {
          // Update throw count and switch to player 2
          const newThrowCount = player1Throws + 1;
          
          await gameRef.update({
            player1Throws: newThrowCount,
            currentPlayer: 2 // Switch to player 2
          });

          // Check if round is complete
          if (newThrowCount >= totalThrows && data.player2Throws >= totalThrows) {
            await calculateAndUpdateScore();
          }
        } else { // localPlayerNum === 2
          // Update throw count and switch to player 1
          const newThrowCount = player2Throws + 1;
          
          await gameRef.update({
            player2Throws: newThrowCount,
            currentPlayer: 1 // Switch to player 1
          });

          // Check if round is complete
          if (data.player1Throws >= totalThrows && newThrowCount >= totalThrows) {
            await calculateAndUpdateScore();
          }
        }

        // Update local UI immediately
        updateTryCounter();
        updateScoreDisplay();

      } catch (err) {
        console.error("Error updating game state:", err);
        alert("Failed to update game state. Please try refreshing the page.");
      }
    }

    // Enhanced scoring calculation with cancellation rules
    async function calculateAndUpdateScore() {
      const gameRef = db.collection('cornholeGames').doc(gameId);
      const doc = await gameRef.get();
      const data = doc.data();

      // Calculate scores with proper cancellation rules
      const p1Bags = data.bagsInPlay.player1 || [];
      const p2Bags = data.bagsInPlay.player2 || [];

      const p1InHole = p1Bags.filter(b => b.isInHole).length;
      const p2InHole = p2Bags.filter(b => b.isInHole).length;
      const p1OnBoard = p1Bags.filter(b => !b.isInHole).length;
      const p2OnBoard = p2Bags.filter(b => !b.isInHole).length;

      // Calculate raw points
      let p1Points = (p1InHole * POINTS_IN_HOLE) + (p1OnBoard * POINTS_ON_BOARD);
      let p2Points = (p2InHole * POINTS_IN_HOLE) + (p2OnBoard * POINTS_ON_BOARD);

      // Apply cancellation rules - only the difference in points is awarded
      const netPoints = Math.abs(p1Points - p2Points);
      const winner = p1Points > p2Points ? 1 : (p1Points < p2Points ? 2 : 0);

      // Update scores
      if (winner === 1) {
        gameScores.player1 += netPoints;
      } else if (winner === 2) {
        gameScores.player2 += netPoints;
      }

      try {
        // Check for game end
        if (gameScores.player1 >= WINNING_SCORE || gameScores.player2 >= WINNING_SCORE) {
          await gameRef.update({
            gameStatus: 'ended',
            gameScores: gameScores
          });
        } else {
          // Start new round with clean state
          await gameRef.update({
            player1Throws: 0,
            player2Throws: 0,
            currentPlayer: 1, // Player 1 starts each new round
            gameScores: gameScores,
            bagsInPlay: {
              player1: [],
              player2: []
            }
          });
        }
      } catch (err) {
        console.error("Error updating score:", err);
      }
    }

    function updateTryCounter() {
      const myThrows = localPlayerNum === 1 ? player1Throws : player2Throws;
      const myTotal = localPlayerNum === 1 ? totalThrows : totalThrows;
      
      if (currentPlayer === localPlayerNum) {
        tryCounterEl.textContent = `Your turn - Throw ${myThrows + 1} of ${myTotal}`;
      } else {
        const opponentThrows = currentPlayer === 1 ? player1Throws : player2Throws;
        tryCounterEl.textContent = `Opponent's turn - Throw ${opponentThrows + 1} of ${totalThrows}`;
      }
    }

    function updateScoreDisplay() {
      scoreDisplayEl.textContent =
        `Score - Player 1: ${gameScores.player1} | Player 2: ${gameScores.player2}`;
    }

    function showResult() {
      const winner = gameScores.player1 > gameScores.player2 ? 1 : 
                    (gameScores.player1 < gameScores.player2 ? 2 : 0);
      const resultMessage = winner === localPlayerNum ? "You win!" : 
                          (winner === 0 ? "It's a tie!" : "You lose!");

      document.getElementById("resultMessage").textContent =
        `${resultMessage} Final Score: Player 1: ${gameScores.player1} - Player 2: ${gameScores.player2}`;
      showScreen("resultScreen");
    }

    function resetGame() {
      const gameRef = db.collection('cornholeGames').doc(gameId);

      gameRef.update({
        player1Throws: 0,
        player2Throws: 0,
        currentPlayer: 1,
        gameStatus: 'started',
        gameScores: { player1: 0, player2: 0 },
        bagsInPlay: { player1: [], player2: [] }
      }).then(() => {
        document.querySelectorAll('.bag').forEach(bag => bag.remove());
        showScreen("gameScreen");
      }).catch((error) => {
        console.error("Error resetting game: ", error);
      });
    }

    // Event Listeners
    gameScreenEl.addEventListener('mousedown', startDrag);
    gameScreenEl.addEventListener('mousemove', updateDrag);
    gameScreenEl.addEventListener('mouseup', endDrag);
    gameScreenEl.addEventListener('mouseleave', endDrag);
    gameScreenEl.addEventListener('touchstart', startDrag);
    gameScreenEl.addEventListener('touchmove', updateDrag);
    gameScreenEl.addEventListener('touchend', endDrag);

    document.getElementById('create-game').addEventListener('click', createNewGame);
    document.getElementById('join-game').addEventListener('click', () => {
      joinGame(document.getElementById('gameIdInput').value.trim());
    });
    document.getElementById('restart-game').addEventListener('click', resetGame);

    // Window resize handler
    window.addEventListener('resize', () => {
      if (currentBagEl) {
        setBagStartPosition(currentBagEl);
      }
    });

    // Helper function for generating player ID
    function generatePlayerId() {
      let stored = localStorage.getItem('playerId');
      if (stored) return stored;
      let newId = Math.random().toString(36).substr(2, 9);
      localStorage.setItem('playerId', newId);
      return newId;
    }

    // Auto-join from URL
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("gameId")) {
      joinGame(urlParams.get("gameId"));
    }
  </script>
</body>
</html>
